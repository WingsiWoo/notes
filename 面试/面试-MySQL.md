# 面试-MySQL

## 数据库基础

### 数据库三大范式是什么

1. 第一范式（1NF）
   - 强调的是列的原子性，数据库的每一列都是不可分割的原子项
   - 尽量合并属性一样的列，确保不产生冗余数据
2. 第二范式（2NF）
   - 在第一范式的基础上要求实体的属性完全依赖于主键
   - 即数据库中的每一行数据必须可以被唯一的区分，区分的根据（唯一属性）就是主键
3. 第三范式（3NF）
   - 任何非主属性不依赖于其他非主属性



### MySQL支持的存储引擎

|     功能     | InnoDB | MyISAM | Memory | Archive |
| :----------: | :----: | :----: | :----: | :-----: |
|   存储限制   |  64TB  | 256TB  |  RAM   | 无限制  |
|   支持事务   |   √    |   ✕    |   ✕    |    ✕    |
| 支持全文索引 |   ✕    |   √    |   ✕    |    ✕    |
|  支持树索引  |   √    |   √    |   √    |    ✕    |
| 支持哈希索引 |   ✕    |   ✕    |   √    |    ✕    |
| 支持数据缓存 |   √    |   ✕    |   -    |    ✕    |
|   支持外键   |   √    |   ✕    |   ✕    |    ✕    |

> 哈希索引（散列索引）进行等值比较的时候比较快
>
> B树索引优于散列索引的是，可以使用部分查询和通配查询，也可以使用<、>和>=等操作符方便数据挖掘
>
> 全文索引是一种特殊类型的索引,它查找的是文本中的关键词,而不是直接比较索引中的值。当使用Blob或者Text这种大文本类型的时候，如果直接使用like搜索这个字段中的某些字符，不走索引，这个时候就要对这个字段使用全文索引（只对英语好用，因为其本身已经用空格进行分词了；而对于中文之类的非自然语言，就需要借助ES和Slor这样的站内索引引擎实现）
>
> 所以MySQL的全文索引实际上非常鸡肋，在实际使用中，缓存使用Redis或者Mongodb实现，查询大文本中的字符用ES或者Solr实现。



#### InnoDB和MyISAM的区别

- ==事务、外键==

  InnoDB支持，MyISAM不支持

- ==全文索引==

  InnoDB不支持，MyISAM支持，故查询效率上MyISAM要更高

- ==索引==

  - InnoDB支持聚簇索引和二级索引，MyISAM中全部都是二级索引

  - 聚簇索引即索引树的叶子结点保存着数据文件。MyISAM中叶子结点保存的是数据文件的指针，一定需要回表操作

    > 所以MyISAM表可以没有主键

- ==表的具体行数==

  - InnoDB没有保存表的具体行数，只有一个估计值，故count(*)的时候需要计算，效率比较慢

    > 事务的原因，不同事务看到的表的总行数可能是不一样的，而count(*)统计的是对本事务而言的可以统计的总行数，所以没有把总行数存储起来方便查询

  - MyISAM中把一个表的总行数存在了磁盘上，如果执行不带条件的count(*)直接到磁盘上读取即可，效率很快。但是如果是带条件的count(\*)，那还是需要计算的

- ==锁==

  - InnoDB支持行级锁和表级锁，默认为行级锁
  - MyISAM只支持表级锁



#### 选择方案

- 如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。
- 如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。
- 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果（缓存）。
- 如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。



### varchar和char的区别

- char是一个定长字段，假如申请了一个字段char(10)，那么无论实际存储多少内容，该字段都占用10个字符
- 而varchar是一个变长字段，其占用空间为实际存储长度+1，额外的一个字符是用来存储该字符串的长度的。
- 检索效率上来说，char > varchar



### in和exist的区别

- exist对外表用loop逐条查询，每次查询都会查看exist的子查询，如果子查询不返回NULL，则exist为真，就把当前loop到的外表记录放入结果集中，反之则丢弃loop到的外表记录。对返回结果的字段没有要求
- in是把外表和内表作hash连接，然后在内存中遍历比较。要求返回结果必须只有一个字段
- 性能问题
  - 假设外表为A，内表为B。由于in需要把B表中的数据全部遍历，因此B表数据越多，in查询效率越慢。而exist并不关心B中的数据有多少，只关心其是否为NULL，因此不会对B进行缓存，其不需要便利操作，只需要多次查询。
    - 查询中两个表的大小相当，用in和exist差别不大
    - 如果大表在外，用in（小表在内遍历快）
    - 如果大表在内，用exist（大表在内查询快）
  - not in查询内外表都使用全表扫描，用不了索引
  - not exist的子查询仍然能用到索引，所以not exist效率一定比not in高



## 事务

### 事务的ACID特性

- ==原子性（Atomicity）==

  原子性是指事务要么全部执行，要么全部不执行。如果事务的执行过程中发生了错误，那么就会回滚到事务执行前的起点，撤销事务执行过的操作（以保证数据库的一致性）

  example：假设一个事务，A向B转账100元，包含两个操作：扣除A账户100元，B账户入账100元。如果这个事务不具有原子性的话，可能会出现这样的情况：扣除A账户100元后，发生了异常导致没有完成第二个操作，导致A明明把钱转出去了，B却没有收到，这100元不翼而飞

- ==一致性（Consistency）==

  数据库中只包含成功事务提交的结果。

- ==隔离性（Isolation）==

  并发执行的各个事务之间不能相互干扰

- ==持久性（Durability）==

  一个事务一旦提交，其对数据库的操作结果就是永久的，接下来的其他操作或故障都不应该对其产生任何影响



### 脏读、幻读、不可重复读

- ==脏读==

  事务A读取了事务B更新的数据后，B事务回滚了，那么A读取到的数据就是脏数据

- ==不可重复读==

  在事务A多次读取的过程中，事务B对该数据进行了更新/删除并提交，导致事务A后面再次读取发现无法读取到这条数据

- ==幻读==

  在事务A多次读取过程中，事务B插入了一条新的数据，导致事务A再次读取发现多了一条数据

  example：事务A要把所有红色数据都改成蓝色，在A修改完毕提交之前，B插入了一条红色数据，A提交之后发现明明自己已经把数据全部都改了，数据库中还是有一条红色数据



### 四种隔离级别

|           隔离级别           | 脏读 | 不可重复读 | 幻读 |
| :--------------------------: | :--: | :--------: | :--: |
| 读未提交（READ UNCOMMITTED） |  √   |     √      |  √   |
|  读已提交（READ COMMITTED）  |  ✕   |     √      |  √   |
| 可重复读（REPEATABLE READ）  |  ✕   |     ✕      |  √   |
|   可串行化（SERIALIZABLE）   |  ✕   |     ✕      |  ✕   |

- ==读未提交==

  所有事务可以看到其他未提交事务的执行结果

- ==读已提交==

  所有事务只能看到其他已提交事务的执行结果

- ==可重复读==（MySQL默认的事务隔离级别）

  确保并发事务的多个实例在同时读取数据时，会看到同样的数据

- ==可串行化==

  通过强制事务排序，使之不可能相互冲突，从而解决了幻读问题。

  > 在每个读的数据行上都加上共享锁，可能会导致大量的锁竞争和超时现象，严重降低并发度



### InnoDB存储引擎是怎么在可重复读隔离级别解决幻读问题的？





## MVCC

### 什么是MVCC？



### MVCC的实现原理



### 怎么利用版本号实现可重复读？



## 索引

### 以a、b、c为顺序建立的联合索引，以下几种查询条件是否会走联合索引？

1. WHERE a = ?

   √

2. WHERE a = ? AND b = ?

   条件ab都会走索引

3. WHERE a = ? AND c = ?

   条件a会走索引，条件c不会走。因为是按照a、b、c顺序建立的，因此索引的排序依据依次是a、b、c，所以根据条件a查询完的结果集中c的值是乱序的，走不了索引

4. WHERE b = ? AND c = ?

   不走索引，理由同3

5. WHERE b = ? AND a = ?

   条件ab都走索引，因为查询优化器会把其优化为3

6. WHERE a = ? AND b = ? AND c = ?

   √



## 慢SQL排查思路

1. 是否为SQL语句本身导致的慢SQL
   - 可以用EXPLAIN语句查看SQL语句的执行计划，是否有走索引
   - SQL语句是否select的数据量非常大
2. SQL慢查询是否是其他外在因素导致的
   - 慢SQL执行期间，请求量是否很大
   - 是否有定时任务在大量操作数据库，导致锁表
3. SQL慢查询是否只在一个机房出现
   - 跨机房请求导致慢SQL
4. SQL慢查询是否由于网络问题
   - 可以用tcpdump抓包看看，是否出现了重传的现象
   - 比如应用到数据库不是直连的，应用→中间件A→中间件B→数据库实例。中间的网络是否正常



## 优化

### count(*)很慢，如何优化？

首先要明确的是，在不同的存储引擎中，count(*)有不同的实现方式：

- MyISAM把表的准确行数存储在了磁盘上，所以如果是不带条件的count(*)，MyISAM引擎会直接到磁盘上读取准确行数，效率十分快；但是如果是带条件的count(\*)，就只能像InnoDB一样读取数据并统计了

- 由于InnoDB的事务特性，在同一时刻表中的总行数对不同事务是不一样的，所以没有存储具体行数，而是会统计本事务可以统计的总行数。

  > 由于count(*)只是统计行数，不需要具体的数据内容，所以InnoDB会选择一棵最小的索引树，在保证正确的前提下，尽可能减少扫描的数据量

  ![image-20220117141403905](https://tva1.sinaimg.cn/large/008i3skNgy1gygn5i6depj30pk09i3z6.jpg)

  > 可以看到不同的事务同时调用count(*)得到的结果是不一样的

​		

优化：

1. 在数据库保存计数

   可以利用事务的特性把问题解决

   <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gygn7nhj7vj30jg0abaah.jpg" alt="image-20220117141607212" style="zoom: 67%;" />

   > 如上图，事务A把计数值+1，但是由于还没提交，所以这个更新操作对事务B是不可见的，因此事务B查看到的结果也是本事务可以统计的数据总数

2. 如果不需要十分精确的行数，可以使用show table status命令查看估计行数

3. 用缓存系统保存计数，如Redis

   存在崩溃丢失的问题，计数不精确

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gygn5blwxrj30jv072dg3.jpg" alt="image-20220117141350890" style="zoom:67%;" />

4. 按照效率排序的话，count(字段) < count(主键id) < count(1) ≈ count(*)

   - 对于count(字段)来说，InnoDB会遍历整张，判断指定的字段是否为空，如果不为空才按行累加

   - 对于count(主键id)来说，InnoDB会遍历整张表，把每一行的主键ID都拿出来，因为主键ID是不可能为空的，就直接按行累加

     > 由于InnoDB已经专门针对count(*)进行优化了，所以就没有再优化count(主键id)

   - 对于count(1)来说，InnoDB会遍历整张表，但不取值，而是直接放个1进去，自然也不可能为空，直接按行累加

     > 这样就比count(主键id)少了一个取值的操作，所以效率更高