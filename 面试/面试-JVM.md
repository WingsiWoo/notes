# 面试-JVM

## 什么是JVM内存结构？

1. ==程序计数器==

   线程私有的一块很小的内存空间，作为当前线程的行号指示器，记录当前正在执行的线程的指令地址

2. ==虚拟机栈==

   线程私有，每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数、动态链接和方法返回值等信息，如果线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛`StackOverFlowError`

3. ==本地方法栈==

   线程私有，用于保存native方法的信息，JVM不会在虚拟机栈中为本地方法创建栈帧，而是简单的动态链接并直接调用该方法

4. ==Java堆==

   所有线程共享，几乎所有的对象实例和数组都要在堆上分配内存，垃圾回收的主要对象

5. ==方法区==

   存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据，也就是永久代。JDK8中不再存在方法区，取而代之的是元数据区，原来的方法区被分为两部分：

   - 加载的类信息（在元数据区中）
   - 运行时常量池（在堆中）



## 方法区的实现

在JDK7及以前是永久代，在JDK8起是元空间

### 永久代

永久代与堆中的老年代在物理地址上是连续的，二者之中任何一个满了都会触发Full GC

JDK7时部分数据不再存储在永久代：

- 字符串常量池`StringTable`移动到Java堆

  程序运行过程中会创建大量字符串，其中很多可能只使用几次，所以StringTable实际上是经常需要回收的，而永久代只有在`Full GC`时才会被回收，导致无用的字符串常量长期霸占永久代内存，导致永久代内存空间不足

- 符号引用移动到本地方法栈

- 静态变量移动到Java堆

> 由于方法区主要存放类的相关信息，所以对于动态生成类的情况很容易导致永久代内存不足，引发OOM

### 元空间

元空间不在虚拟机中，而是在本地内存中，一般情况下元空间大小仅受本地内存大小影响（这样就大大降低了Full GC的触发概率）

转换原因：

- 方法区用于存储类的相关信息，难以确定具体的大小，因此如何合理的设置永久代大小也比较困难。因为老年代与永久代是相连的，永久代设置过小容易永久代溢出，过大容易老年代溢出（都会触发`Full GC`）
- 字符串常量池存放在永久代中，回收效率低，容易永久代内存溢出
- 永久代给GC带来不必要的复杂性



## GC完整过程

堆被划分为两个空间，新生代和老年代，其中新生代又分为Eden区、From区、To区（默认占比为8:1:1）

1. 对象优先在Eden区分配内存（如果是超大对象，可能会直接在老年区分配内存，因此要避免超大对象的创建，因为如果这个超大对象只使用一次，理论上应该尽快回收，但由于其在的老年代很受GC，所以可能要等很久才会被回收），当Eden区内存不足时，会触发一次**`Minor GC`（采用复制算法）**

   - 把Eden区中无用的对象清理掉
   - 把Eden区中存活的对象移动到From区

2. **Eden区满**，再次触发`Minor GC`

   - 把Eden区和From区中无用的对象清理掉
   - 把Eden区和From区中存活的对象移动到To区
   - From区和To区角色对换（即当前的To区变为下一次GC的From区）

3. 对象每在From区和To区之间移动一次，年龄就会+1，到达一定年龄（默认为15）后就会被移动到老年代

4. 正常来说，老年代中的对象比较稳定，因此很少GC

5. 触发**`Major GC`的情况（采用标记-清除或标记-整理算法）**

   - `Minor GC`后进入老年代的对象所需内存大于老年代的可用内存
   - 老年代空间不足/永久代空间不足（JDK7前）
   - 超大对象所需内存大于老年代可用内存
   - 调用`System.gc()`，系统建议执行`Major GC`，但不一定执行

   > `Major GC（Full GC）`的回收对象为新生代、老年代、永久代



## 类加载

1. 加载

   1. 通过类的全限定类名获取该类的二进制流
   2. 将该二进制流的静态存储结构转为方法区的运行时数据结构
   3. 在堆中为该类生成一个`class`对象

2. 连接

   1. 验证：验证该`class`文件中的字节流信息是否符合JVM要求，不会威胁到JVM的安全

   2. 准备：为该`class`对象的静态变量分配内存，初始化其初始值（零值）

      > 这些内存都在方法区中进行分配，具体的赋值在初始化阶段完成
      >
      > 这里不包含用`final`修饰的`static`变量，因为==`final`在编译时就会分配内存了，准备阶段会显式初始化==

   3. 解析：该阶段主要完成符号引用转化为直接引用

3. 初始化：调用类构造器（此处才开始执行类中定义的java代码）

4. 使用

5. 卸载

   条件：

   1. 该类的所有实例对象都已经被回收（即Java堆中不存在任何该类的实例）

   2. 加载该类的`ClassLoader`已经被回收（因为JVM始终保持对类加载器的引用，而类加载器保持着对其加载的类的`class`对象的引用，所以如果类加载器没有被回收，那么该类的class对象始终是可达的）

      > 这也是自定义`ClassLoader`存在的意义，因为系统的`ClassLoader`永远是可达的，那么由它们加载的类永远不会被卸载

   3. 该类的`class`对象在任何地方都没有被引用，无法通过反射访问该类

   > 总结来说就是三个不可达：实例对象不可达、类加载器不可达、`class`不可达

   类的卸载其实就是在方法区中清空该类的信息



## 双亲委派机制

### 什么是双亲委派机制？

双亲委派机制即当一个类加载器收到加载请求时，不会先自己去尝试类加载，而是先委托父类进行加载，当父类无法进行加载时才交还给子类进行加载。因此所有的类加载请求都会被传递到`Bootstrap ClassLoader`



### 为什么要使用双亲委派机制？

1. ==避免类的重复加载==

   对于某一个类，无论是哪个类加载器要加载类，最终都会通过双亲委派机制由某一个固定的类加载器进行加载。当这个负责加载该类的类加载器发现自己已经加载过这个类了，就不会再次加载了，从而避免了类的重复加载

2. ==保护核心类库的加载==

   Java主要支持4种类加载器：

   - `Bootstrap ClassLoader` 启动类加载器：主要负责加载Java核心类库
   - `Extention ClassLoader` 标准扩展类加载器：主要负责加载扩展类
   - `Application ClassLoader` 应用类加载器：主要负责加载当前应用`classpath`下的所有类
   - `User ClassLoader` 用户自定义类加载器：用户自定义的类加载器，可以加载指定路径下的`class`文件

   ![preview](https://pic4.zhimg.com/v2-eb6ffa2110335ebb79b864e14a23c48b_r.jpg)

   > 注意它们之间不是继承关系，而是组合关系（即子类中定义一个父类加载器的属性）

   双亲委派机制使得核心类永远都是由`Bootstrap ClassLoader`负责加载的，避免了核心API被恶意篡改引起严重问题



### 破坏双亲委派机制

自定义类加载器，继承`ClassLoader`类，重写`loadClass`方法和`findClass`方法（先尝试自己加载，如果不行再委托父加载器加载）

Tomcat，应用的类加载器优先自行加载应用目录下的`class`，加载不了才委派给父加载器，3个目的：

1.  对于各个`webapp`中的`class`和`lib`，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，并且`lib`要可共享，避免浪费资源
2.  使用单独的`ClassLoader`加载tomcat自身的类库，避免破坏
3.  热部署（修改项目代码后无需重启tomcat就能让修改生效）



