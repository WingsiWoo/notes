# 面试-JVM

## 什么是JVM内存结构？

1. ==程序计数器==

   线程私有的一块很小的内存空间，作为当前线程的行号指示器，记录当前正在执行的线程的指令地址

2. ==虚拟机栈==

   线程私有，每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数、动态链接和方法返回值等信息，如果线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛`StackOverFlowError`

3. ==本地方法栈==

   线程私有，用于保存native方法的信息，JVM不会在虚拟机栈中为本地方法创建栈帧，而是简单的动态链接并直接调用该方法

4. ==Java堆==

   所有线程共享，几乎所有的对象实例和数组都要在堆上分配内存，垃圾回收的主要对象

5. ==方法区==

   存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据，也就是永久代。JDK8中不再存在方法区，取而代之的是元数据区，原来的方法区被分为两部分：

   - 加载的类信息（在元数据区中）
   - 运行时常量池（在堆中）



## 什么是JVM内存模型（JMM）？

由于主存与CPU的速度差异十分大，所以在传统的计算机内存架构中会引入高速缓存来作为主存和CPU之间的缓冲，一般都有多级缓存，分为L1、L2、L3缓存。因为这些缓存的存在，**提升了数据的访问性能，也减轻了数据总线上数据传输的压力**。

但是同时也带来了以下问题：

1. ==缓存一致性问题==

   在多CPU的系统中，每个CPU内核都拥有自己的高速缓存，它们共享同一主存。当多个CPU的操作都涉及同一块主存区域的时候，就可能会导致不同CPU的高速缓存内的数据不一致问题

2. ==处理器优化和指令重排序==

   为了进一步提升CPU的执行效率，使得处理器内部的运算单元能够最大化被充分利用，处理器会对输入的指令进行优化，指令重排是处理器优化的其中一种。重排序可以分为三种类型：

   - **编译器优化的重排序（指令重排）**

     编译器在不改变单线程环境下程序运算结果的前提下，可以重新安排语句的执行顺序

   - **指令集并行的重排序**

     采用指令级并行技术（如流水线技术）来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序

   - **内存系统的重排序**

     由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行

   > Java并发的三个问题：可见性问题、原子性问题、有序性问题，实际上就是缓存一致性（➡️可见性问题）、处理器优化（➡️原子性问题）、指令重排（➡️有序性问题）造成的



为了解决上面的问题，规范内存的读写操作，JMM定义了一组排序规则来**保证线程的可见性**。这一组规则就是**`Happens-Before`**，JMM 规定，要想保证 B 操作能够看到 A 操作的结果(无论它们是否在同一个线程)，那么 A 和 B 之间必须满足 **`Happens-Before`** ：

1. ==单线程规则==

   一个线程中的每个动作都`happens-before`于该线程的后续动作

2. ==监视器锁定规则==

   监视器的解锁动作一定`happens-before`于该监视器的后续锁定操作

3. ==volatile变量规则==

   对volatile字段的写入操作`happens-before`于对其的读取操作

4. ==线程start规则==

   线程start()方法的执行`happens-before`该启动线程内的任何执行动作

5. ==线程join规则==

   一个线程内的所有动作都`happens-before`于该线程join()方法返回

6. ==传递性==

   如果A `happens-before` B，B `happens-before` C，那么A `happens-before` C

> 即JMM描述的是多线程对共享内存修改后彼此之间的可见性，另外还确保了正确的Java代码可以在不同体系结构的处理器上正确运行



## 方法区的实现

在JDK7及以前是永久代，在JDK8起是元空间

### 永久代

永久代与堆中的老年代在物理地址上是连续的，二者之中任何一个满了都会触发Full GC

JDK7时部分数据不再存储在永久代：

- 字符串常量池`StringTable`移动到Java堆

  程序运行过程中会创建大量字符串，其中很多可能只使用几次，所以`StringTable`实际上是经常需要回收的，而永久代只有在`Full GC`时才会被回收，导致无用的字符串常量长期霸占永久代内存，导致永久代内存空间不足

- 符号引用移动到本地方法栈

- 静态变量移动到Java堆

> 由于方法区主要存放类的相关信息，所以对于动态生成类的情况很容易导致永久代内存不足，引发OOM

### 元空间

元空间不在虚拟机中，而是在本地内存中，一般情况下元空间大小仅受本地内存大小影响（这样就大大降低了Full GC的触发概率）

转换原因：

- 方法区用于存储类的相关信息，难以确定具体的大小，因此如何合理的设置永久代大小也比较困难。因为老年代与永久代是相连的，永久代设置过小容易永久代溢出，过大容易老年代溢出（都会触发`Full GC`）
- 字符串常量池存放在永久代中，回收效率低，容易永久代内存溢出
- 永久代给GC带来不必要的复杂性



## 垃圾回收机制

### GC算法

#### 根搜索算法（可达性算法）

从GC ROOT节点开始，寻找对应的引用节点，即从GC ROOT可达的节点仍然被引用，无需回收；从GC ROOT不可达的节点已经不再被引用，需要回收。

Java中可以作为GC ROOT的对象：

- 虚拟机栈中引用的对象（本地变量表）
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中引用的对象（Native对象）

> 基本所有的GC算法都引用根搜索算法来判断对象是否需要回收



#### 标记-清除算法

1. 使用根搜索算法对可达节点（存活对象）进行标记
2. 标记完成后，再扫描整个空间中未被标记的对象进行直接回收

标记-清除算法直接回收不存活的对象，会造成内存碎片。适用于存活对象比较多的情况



#### 标记-复制算法

复制算法把内存划分为两个区间，使用此算法时，所有动态分配的对象都只能分配在其中一个区间（活动区间），另外一个区间（空闲区间）则是空闲的

1. 使用根搜索算法搜索存活对象，把存活对象复制到空闲区间
2. 扫描完毕后，把活动区间中的所有对象全部进行回收
3. 此时空闲区间和活动区间身份反转

标记-复制算法效率很高，不会产生内存碎片，但是浪费了50%的内存空间，适用于存活对象比较少的情况（否则一直把存活对象复制来复制去）

> 对新生代内存的回收（Minor GC）主要采用标记-复制算法



#### 标记-整理算法

有一个指针指向空闲区和非空闲区的分界线

1. 使用根搜索算法对存活对象进行标记
2. 把存活对象向一边移动，覆盖回收对象
3. 更新空闲边界指针

效率不高，但是没有像复制算法的50%内存浪费，也不会产生内存碎片

> 对老年代的回收（Major GC）主要采用标记-整理算法



#### 分代收集算法

堆被划分为两个空间，新生代和老年代，其中新生代又分为Eden区、From区、To区（默认占比为8:1:1）

1. 对象优先在Eden区分配内存（如果是超大对象，可能会直接在老年区分配内存，因此要避免超大对象的创建，因为如果这个超大对象只使用一次，理论上应该尽快回收，但由于其在的老年代很少GC，所以可能要等很久才会被回收），当Eden区内存不足时，会触发一次**`Minor GC`（采用复制算法）**

   - 把Eden区中无用的对象清理掉
   - 把Eden区中存活的对象移动到From区

2. **Eden区满**，再次触发`Minor GC`

   - 把Eden区和From区中无用的对象清理掉
   - 把Eden区和From区中存活的对象移动到To区
   - From区和To区角色对换（即当前的To区变为下一次GC的From区）

3. 对象每在From区和To区之间移动一次，年龄就会+1，到达一定年龄（默认为15）后就会被移动到老年代

4. 正常来说，老年代中的对象比较稳定，因此很少GC

5. 触发**`Major GC`的情况（采用标记-整理算法）**

   - `Minor GC`后进入老年代的对象所需内存大于老年代的可用内存
   - 老年代空间不足/永久代空间不足（JDK7前）
   - 超大对象所需内存大于老年代可用内存
   - 调用`System.gc()`，系统建议执行`Major GC`，但不一定执行

   > `Major GC（Full GC）`的回收对象为新生代、老年代、永久代



### GC收集器

每一个GC收集器都存在`Stop The World`的问题，即JVM为了要进行GC而暂停应用程序的执行，除GC所需的线程外，其他线程都进入阻塞状态，直到GC完成。GC收集器的优劣是通过其减少`Stop The World`的程度来评价的



#### Serial（-XX:+UseSerialGC）

Serial收集器是JVM中最基本、最早的收集器，在JDK1.3之前是JVM**新生代收集器**的唯一选择。顾名思义，Serial收集器是一个串行收集器，其关于GC的操作执行时（包括标记）都需要Stop The World，暂停所有的用户线程，直到回收结束。

- 使用复制算法
- 只有一个GC线程
- 对于限定单个CPU的环境，由于没有线程交互的开销，专心做垃圾收集，所以相对其他的收集器是最高效的



#### SerialOld（-XX:+UseSerialGC）

是Serial收集器的**老年代收集器**版本

- 使用标记-整理算法
- 在JDK1.5及之前与`ParallelScavenge`收集器搭配使用
- 作为CMS收集器的后备方案，如果CMS出现`Concurrent Mode Failure`，则SerialOld将作为后备收集器



#### ParNew（-XX:+UseParNewGC）

其实就是Serial收集器的多线程版本，有多个GC线程并发进行回收。除了Serial收集器外，只有它能与CMS收集器配合工作

- 使用复制算法
- 是许多运行在Server模式下的JVM首选**新生代收集器**
- 单CPU情况下，效率远低于Serial收集器



#### ParallelScavenge（-XX:+UseParallelGC）

吞吐量优先收集器，也是一个**新生代收集器**

- 使用复制算法
- 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即`吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）`



#### ParallelOld（-XX:+UseParallelOldGC）

JDK1.6之后才开始提供，在此之前，`ParallelScavenge`只能选择SerialOld来作为其**老年代的收集器**，这严重拖累了`ParallelScavenge`整体的速度。`ParallelOld`的出现，提高了`ParallelScavenge`的效率

- 是并行收集器，使用标记-整理算法
- 在注重吞吐量与CPU数量大于1的情况下，都可以优先考虑`ParallelScavenge + ParalleloOld`收集器。



#### 🌟CMS（-XX:+UseConcMarkSweepGC）

CMS是一个**老年代收集器**，全称 `Concurrent Low Pause Collector`，是JDK1.4后期开始引用的新GC收集器，在JDK1.5、1.6中得到了进一步的改进。

- 使用标记-清理算法
- 用两次短暂的`Stop The World`来代替串行或并行标记整理算法时候的长暂停
- 是一个对于响应时间的重要性需求大于吞吐量需求的收集器，适用于要求服务器响应速度高的情况

执行过程如下：

1. ==初始标记（STW initial mark）——第一次短暂暂停==

   需要`Stop The World`，扫描**与GC ROOT直接关联的对象**，并作标记

2. ==并发标记（Concurrent marking）==

   在初始标记的基础上继续向下追溯标记，该过程无需STW，用户线程和GC线程并发执行

3. ==并发预清理（Concurrent precleaning）==

   查找并发标记阶段进入老年代的对象，通过这一阶段，减少下一阶段——重新标记阶段的工作量，因为下一阶段需要STW，要尽可能缩短它执行的时间

4. ==重新标记（STW remark）——第二次短暂暂停==

   需要`Stop The World`，**从GC ROOT开始查找并标记并发标记阶段遗漏的对象**（在并发标记阶段结束后对象状态更新导致的遗漏），**并处理对象关联**。这个阶段耗时要比初始标记长，并且这个阶段可以并行标记

5. ==并发清理（Concurrent sweeping）==

   应用线程和GC清除线程可以并发执行

6. ==并发重置（Concurrent reset）==

   重置CMS收集器的数据结构，以便下一次垃圾回收，这一阶段也是并发的

缺点：

1. ==使用标记-清除算法进行清理，导致内存中会产生内存碎片。==

   CMS收集器做了一个小优化，把未分配的空间汇总成一个列表，当JVM需要分配内存空间时，从这个列表寻找可用空间即可，加快了分配内存的速度。但是由于内存碎片的存在，可能无法找到足够大的连续的内存空间，导致引发Full GC

2. ==需要更多的CPU资源==

   CMS收集器的大部分阶段都是GC线程和用户线程并发执行的，这样就需要占用更多的CPU资源，牺牲一部分吞吐量

3. ==需要更大的堆空间==

   由于CMS标记阶段应用程序仍然并发执行，就可能会存在需要分配内存空间的问题。为了保障CMS执行期间应用程序可以正常分配内存空间，就需要预留一部分内存空间，即还没有用完就开始进行GC。

4. ==无法处理浮动垃圾==

   在并发清理的过程中也可能会产生垃圾，但是由于本次GC并没有对其标记过，所以这些垃圾只能等到下一次GC的时候处理，这种垃圾就叫浮动垃圾

   > CMS默认在老年代空间使用`68%`时候启动垃圾回收。可以通过`-XX:CMSinitiatingOccupancyFraction=n`来设置这个阀值。
   >
   > 如果这个阈值设置的太大，就会导致CMS触发太晚，可能会引发内存无法分配成功的问题，抛出`Concurrent Mode Failure`，这是CMS独有的错误。发生这个错误的时候可以把阈值调小或通过`-XX:+UseCMSCompactAtFullCollection`参数开启空间碎片整理。（不整的话就会退化为SerialOld收集器）



#### GarbageFirst（G1）

- 负责**年轻代和老年代的GC**（`Young GC`和`Old GC`）

- 保留了分代概念

- 可控的停顿时间，可以通过 `-XX:MaxGCPauseMillis=200` 指定期望的停顿时间

  - 使用停顿预测模型来满足用户指定的停顿时间目标，并基于这个时间目标来选择进行垃圾回收的区块数量（只是尽量满足，不是绝对的）
  - G1采用增量回收的方式，每次回收一些region，而不是整堆回收

- G1收集器把堆划分为一个个大小相等的小块`region`，每一块的内存是连续的，G1在标记阶段结束之后就知道哪些`region`基本上是垃圾，存活对象极少，会优先回收这些区块，因为从这些区块能很快释放得到较大的连续内存空间。这也是被称为`GarbageFirst`的原因

  > 这种方式也在一定程度上优化了内存碎片化的问题
  >
  > 同时这些块也可以充当Eden、Survivor、Old 三种角色，不是固定的，使得内存可以更加灵活使用
  >
  > 从整体来看是基于标记-整理算法实现的，但是从局部（region之间）来看是基于复制算法实现的

- Full GC的时候仍然需要STW，所以应该尽量避免Full GC

执行阶段：

1. ==初始标记（Initial Marking）==

   与CMS收集器的第一个阶段很相似，只标记与GC ROOT直接关联的对象，**需要STW**

2. ==并发标记（Concurrent Marking）==

   从GC ROOT开始对堆中对象进行可达性分析，可以与用户线程并发执行

3. ==最终标记（Final Marking）==

   标记并发标记期间遗漏的对象，**需要STW**，可以并行标记（多个标记线程同时执行）

4. ==筛选回收（Live Data Counting and Evacuation）==

   对Region的回收价值和成本进行计算和排序，根据用户所期望的GC停顿时间来制定回收计划并按照计划进行回收，需要STW

   > 这个阶段实际上也是可以与用户线程并发执行的，但是由于回收的执行时间已经是用户可控制的，为了提高回收效率，G1选择了STW执行



### 为什么需要两次标记（可达性算法标记的对象一定会被回收吗）

如果对象在可达性分析中没有与GC ROOT的引用链的话，就会被第一次标记并进行一次筛选，筛选的条件是对象是否有重写`finalize()`方法并调用，如果没有的话就没有什么后顾之忧了，可以进行回收；

有的话就会把这个对象放入`F-Queue`的队列中，虚拟机会触发一个低优先级的`finalize`线程去执行。虚拟机不会保证`F-Queue`队列内的对象的`finalize`方法一定能执行完毕，如果`finalize()`执行缓慢或者发生了死锁，造成`F-Queue`一直等待，引起内存系统的崩溃。

GC会对`F-Queue`中的`finalize`执行完毕的对象进行第二次标记，被第二次标记的对象就会被移入等待回收的集合中等待回收，这时才成为真正的垃圾

JDK并不推荐使用`finalize()`方法进行资源回收，在JDK9中，已经将 `Object.finalize()` 标记为 `deprecated`：

- GC并不保证`finalize()`一定会执行/一定能执行完毕
- 如果`finalize()`方法使用不当，可能会引起死锁，导致内存系统崩溃
- 建议使用`try-with-resouces`或者`try- finally`机制对资源进行回收



### Safe Point

只有线程运行到安全点时，才能Stop The World：

- 循环的末尾（避免大循环导致线程长时间无法暂停）
- 方法临返回前 / 调用方法的call指令后
- 可能抛异常的位置



### Minor GC与Major GC？

- Minor GC
  - 只收集新生代
  - 触发条件：Eden区满
- Major GC / Full GC
  - 收集整个堆和方法区
  - 触发条件：
    - 通过Minor GC后进入老年代的大小大于老年代的可用内存
    - 老年代空间不够分配新的内存
    - 永久代空间内存不足（1.7及以前才有），1.8之后用元空间取代了永久代，减少了Full GC的频率
    - 由Eden区、From区复制到To区中，To区内存不足，这时则把对象移到老年代，若老年代仍然内存不足，则触发Major GC
    - 调用System.gc()，系统建议执行Full GC，但不保证一定会执行



### System.gc()

首先要明确的一点是，程序调用了`System.gc()`，代表显式的触发`Full GC`，但是系统不保证一定会执行。该方法只有在`justRanFinalization = true`的时候才会执行，而这个属性在调用`runFinalization()`的时候会被修改为`true`。

所以如果想要保证`System.gc()`一定会触发`Full GC`，就要与`runFinalization()`方法搭配使用

```java
System.gc();
runtime.runFinalizationSync();
System.gc();
```

> 不过不建议这样做，因为JVM有自己的GC策略，不建议手动GC



### 空间分配担保原则

JVM的分配内存机制有三大原则和空间分配担保机制：

1. 优先分配到Eden区

2. 大对象直接进入老年代

3. 长期存活的对象分配到老年代

4. 空间分配担保机制

   在发生`Minor GC`之前，虚拟机会检查老年代最大可用的连续内存空间是否大于新生代所有对象的总空间（是否具有足够可用空间）

   - 如果大于，说明有足够空间可用，则此次`Minor GC`是安全的
   - 如果小于，则虚拟机会查看`HandlePromotionFailure`参数是否允许担保失败
     - `HandlePromotionFailure = true`，则会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。如果大于，则尝试进行一次`Minor GC`，但是这次`Minor GC`仍然是有风险的；如果小于，则进行一次`Full GC`
     - `HandlePromotionFailure = false`，说明不允许`Minor GC`失败的情况产生，直接进行一次Full GC



### 为什么说Minor GC是不安全/有风险的？

这是因为新生代采用复制算法进行GC，如果大量对象在Minor GC后仍然存活，那么这些对象就全部都会复制进S区，然后S区是很小的（Eden:From:To=8:1:1），当S区空间不足时就需要把无法容纳的对象放入老年代。

但是前提是老年代有足够的空间能够容纳对象，这时候就需要进行空间分配担保，由于有多少对象能在Minor GC之后存活是不可知的，因此只能通过过去的垃圾回收后晋升到老年代对象大小的平均值作为参考，来评估这次Minor GC的风险。

通过开启空间分配担保，虽然无法完全避免Minor GC的风险，但是在一定程度上降低了Full GC的执行频率



### 四种引用

1. ==强引用==

   是最常见的普通对象引用，比如new一个对象创建的就是强引用。在强引用面前，即使内存不足，JVM宁愿抛出OOM也不会通过回收强引用对象来解决内存不足问题即只要有强引用指向一个对象，那么就认为该对象是存活的。

   > 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就意味着此对象可以被垃圾收集了。但要注意的是，并不是赋值为null后就立马被垃圾回收，具体的回收时机还是要看垃圾收集策略的。

2. ==软引用==

   只有当内存不足时，JVM才会在抛出OOM之前清理软引用指向的对象。JVM会尽可能优先回收长时间闲置不用的软引用指向的对象，对那些刚构建的或者刚使用过的软引用指向的对象尽可能的保留。

   > 基于软引用的这些特性，**软引用可以用来实现很多内存敏感点的缓存场景**，即如果内存还有空闲，可以暂时缓存一些业务场景所需的数据，当内存不足时就可以清理掉，等后面再需要时，可以重新获取并再次缓存。这样就确保在使用缓存提升性能的同时，不会导致耗尽内存。

   ```java
   // 软引用通常和一个引用队列联合使用
   SoftReference<List<Foo>> ref = new SoftReference<List<Foo>>(new LinkedList<Foo>());
   // 程序中可以添加要被软引用指向的对象进入队列中
   List<Foo> list = ref.get();
   // 因为不知道是否已被回收，因此软引用使用前必须进行判空
   if (list != null)
   {
       list.add(foo);
   }
   ```

3. ==弱引用==

   弱引用指向的对象是十分临近`finalize`状态的情况，当弱引用被清除时，就符合`finalize`的条件了。

   > 弱引用与软引用最大的区别就是弱引用比软引用的生命周期更短暂。垃圾回收器会扫描它所管辖的内存区域的过程中，只要发现弱引用的对象，不管内存空间是否有空闲，都会回收它。

   ```java
   Object obj = new Object();
   WeakReference<Object> wf = new WeakReference<Object>(obj);
   obj = null;
   // 可能会返回null
   wf.get();
   // 返回是否被垃圾回收器标记为即将回收的垃圾
   wf.isEnQueued();
   ```

4. ==幻想引用/虚引用==

   如果一个对象仅持有虚引用，就相当于没有任何引用一样，随时都可能会被回收。不能通过虚引用访问对象，它仅仅提供了一种确保对象`finalize`后做某些事情（如`Post-Mortem`清理机制）的机制，也有人利用虚引用监控对象的创建和销毁

   > 如今的Java平台，开始采用`java.lang.ref.Cleaner` 代替`finalize`。`Cleaner` 的实现使用了幻象引用。这是一种常见的`post-mortem`清理机制。这个`Cleaner` 的操作都是独立的，有自己的运行线程，避免意外死锁的问题。

   ```java
   Object obj = new Object();
   PhantomReference<Object> pf = new PhantomReference<Object>(obj);
   obj=null;
   // 永远返回null
   pf.get();
   // 返回是否从内存中已经删除
   pf.isEnQueued();　　
   ```

> 除了虚引用，其他引用都可以访问到所指的对象。**利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态**。所以对于软引用、弱引用之类，垃圾收集器可能会存在**二次确认**的问题，以确保处于弱引用状态的对象没有改变为强引用。



## 类加载

1. ==加载==

   1. 通过类的全限定类名获取该类的二进制流
   2. 将该二进制流的静态存储结构转为方法区的运行时数据结构
   3. 在堆中为该类生成一个`class`对象

2. ==连接==

   1. ==验证==：验证该`class`文件中的字节流信息是否符合JVM要求，不会威胁到JVM的安全

   2. ==准备==：为该`class`对象的静态变量分配内存，初始化其初始值（零值）

      > 这些内存都在方法区中进行分配，具体的赋值在初始化阶段完成
      >
      > 这里不包含用`final`修饰的`static`变量，因为==`final`在编译时就会分配内存了，准备阶段会显式初始化==

   3. ==解析==：该阶段主要完成符号引用转化为直接引用

3. ==初始化==：调用类构造器（此处才开始执行类中定义的java代码）

4. ==使用==

5. ==卸载==

   条件：

   1. 该类的所有实例对象都已经被回收（即Java堆中不存在任何该类的实例）

   2. 加载该类的`ClassLoader`已经被回收（因为JVM始终保持对类加载器的引用，而类加载器保持着对其加载的类的`class`对象的引用，所以如果类加载器没有被回收，那么该类的class对象始终是可达的）

      > 这也是自定义`ClassLoader`存在的意义，因为系统的`ClassLoader`永远是可达的，那么由它们加载的类永远不会被卸载

   3. 该类的`class`对象在任何地方都没有被引用，无法通过反射访问该类

   > 总结来说就是三个不可达：实例对象不可达、类加载器不可达、`class`不可达

   类的卸载其实就是在方法区中清空该类的信息



## 双亲委派机制

### 什么是双亲委派机制？

双亲委派机制即当一个类加载器收到加载请求时，不会先自己去尝试类加载，而是先委托父类进行加载，当父类无法进行加载时才交还给子类进行加载。因此所有的类加载请求都会被传递到`Bootstrap ClassLoader`



### 为什么要使用双亲委派机制？

1. ==避免类的重复加载==

   对于某一个类，无论是哪个类加载器要加载类，最终都会通过双亲委派机制由某一个固定的类加载器进行加载。当这个负责加载该类的类加载器发现自己已经加载过这个类了，就不会再次加载了，从而避免了类的重复加载

2. ==保护核心类库的加载==

   Java主要支持4种类加载器：

   - `Bootstrap ClassLoader` 启动类加载器：主要负责加载Java核心类库
   - `Extention ClassLoader` 标准扩展类加载器：主要负责加载扩展类
   - `Application ClassLoader` 应用类加载器：主要负责加载当前应用`classpath`下的所有类
   - `User ClassLoader` 用户自定义类加载器：用户自定义的类加载器，可以加载指定路径下的`class`文件

   ![preview](https://pic4.zhimg.com/v2-eb6ffa2110335ebb79b864e14a23c48b_r.jpg)

   > 注意它们之间不是继承关系，而是组合关系（即子类中定义一个父类加载器的属性）

   双亲委派机制使得核心类永远都是由`Bootstrap ClassLoader`负责加载的，避免了核心API被恶意篡改引起严重问题



### 破坏双亲委派机制

自定义类加载器，继承`ClassLoader`类，重写`loadClass`方法和`findClass`方法（先尝试自己加载，如果不行再委托父加载器加载）

Tomcat，应用的类加载器优先自行加载应用目录下的`class`，加载不了才委派给父加载器，3个目的：

1.  对于各个`webapp`中的`class`和`lib`，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，并且`lib`要可共享，避免浪费资源
2.  使用单独的`ClassLoader`加载tomcat自身的类库，避免破坏
3.  热部署（修改项目代码后无需重启tomcat就能让修改生效）



## 如何理解“不使用的对象应该手动赋值为null”？

1. 局部变量表是GC中重要的`GC ROOT`

   JVM中的GC一般采用可达性分析算法，即从`GC ROOT`开始搜索可达（存活）的对象。创建的对象都会存放在局部变量表的一个槽中

2. 局部变量表的可复用性

   局部变量表中的槽是可以复用的，如果代码已经离开了某个变量的作用域，那么该变量的槽可以被重复利用，之后如果产生了新的变量，就会覆盖这个槽中原有的变量。但是如果之后不再有任何对局部变量表的读写操作，这个变量就会一直占用着这个槽，局部变量表也就会一直保持着对它的引用，GC标记的时候就会误以为该变量是存活的，并不会回收这个变量。

> 这种关联没有及时被打断，在大多数情况下没什么影响。但是如果后面的代码有一些耗时很长的操作，前面又定义了一堆占用很大内存实际上不会再被使用的变量，手动赋为`null`值还是有意义的。



## 为什么static方法中不可以引用super、this？

1. 初始化时机

   static方法在类加载的时候就已经存在了，但是对象是在创建时才分配到堆中。也就是说static方法的出现时机把super、this要早，一个先存在的方法尝试去引用一个现在可能还未创建的对象，自然是不符合逻辑的

2. 局部变量表

   一个方法只能引用自己局部变量表中的对象，普通方法的局部变量表的第一个槽中的变量一定是this，即用于传递方法所属对象实例的引用；但是static方法是直属于类的，其局部变量表内并没有this变量，所以也就不可以引用了



## OOM

#### 内存溢出与内存泄漏

- 内存溢出

  空闲内存不足，并且垃圾收集器无法提供更多内存（垃圾回收之后仍然内存不足）

  > 在抛出OOM之前，垃圾收集器通常会被触发，尝试解决内存不足的问题。如果垃圾回收后仍无法提供足够内存，就会抛出OOM

- 内存泄漏

  某些对象不会再被使用到，但是无法被GC回收

  > 内存泄漏不会立刻引起程序崩溃，而是逐渐占用内存，直到内存不足时抛出OOM

  1. **静态集合类引发内存泄漏**

     放入静态集合中的对象，即使显式赋值为null，也不会被回收，因为静态集合中仍然保存着对其的强引用。因此使用完后要记得把对象从集合中移除/清空集合

  2. **接收器、监听器注册没取消造成的内存泄漏**

  3. **连接没有及时关闭造成的内存泄漏**

  4. **单例引发的内存泄漏**

     单例的不当使用，如果创建的单例对象只需要使用一次，这个对象就会一直占用内存，并且无法回收

     ```java
     public class AppManager {
         private static AppManager instance;
         private Context context;
       
         private AppManager(Context context) {
           // ✕：如果传入的是Activity的Context，这个Context对应的Activity退出时，由于其Context被单例对象持有，其生命周期等于整个应用程序的生命周期，所以Activity对象无法正常被回收
           this.context = context;
           // √：Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。
           this.context = context.getApplicationContext();
         }
       
         public static AppManager getInstance(Context context) {
           if (instance == null) {
           	instance = new AppManager(context);
           }
           return instance;
           }
         }
     ```

  5. **匿名内部类/非静态内部类和异步线程引发的内存泄漏**

     ```java
     public class MainActivity extends AppCompatActivity {
       private static TestResource mResource = null;
       @Override
       protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         if(mManager == null){
           mManager = new TestResource();
         }
         //...
       }
       class TestResource {
         //...
       }
     }
     ```

     如上述代码，`TestResource`非静态内部类默认持有一个对外部类`MainActivity`的引用。

     >  因此非静态内部类可以访问外部类的成员变量

     而`MainActivity`又创建了一个静态的`TestResource`实例，这样就会导致该静态实例会一直持有对`MainActivity`的引用，导致`Activity`的内存资源不能正常回收。

     正确的做法为：将该内部类设为静态内部类（不会持有对外部类的引用）或将该内部类抽取出来封装成一个单例



### 排查思路

1. 修改JVM启动参数，直接增加内存

   > -Xmx、-Xms

2. 检查错误日志，查看OOM错误前是否有其他异常或错误

3. 对程序进行分析，寻找可能发生内存溢出/内存泄漏的问题

   - 对数据库查询中是否有一次性获取全部数据的操作

     如果数据库中数据量十分大，一次性全部读出来可能就会引发OOM。因此一般建议采用分页查询

   - 是否存在死循环或递归

   - 是否存在大循环重复创建对象实例

   - 检查静态集合对象是否有使用完后未清除的问题

     集合对象始终保持对所存储对象的引用，会使得这些对象无法回收

4. 使用内存查看工具动态查看内存情况



## 堆和栈的区别

1. 内存分配

   - 栈由系统自动分配内存，无需程序员对内存进行管理（自动出栈）
   - 堆由程序员自己申请，是动态分配的，需要手动释放内存（c中malloc申请内存后需要手动free，Java中JVM添加了GC机制自动回收内存）

2. 大小限制

   - 栈是向低地址扩展的数据结构，是一块连续的内存空间，其最大容量是系统预先规定好的，如果超过内存将抛出`StackOverflow`，空间较小

     > `-Xss <size>`调整规定的栈大小
     >
     > 经典`StackOverflow`：死循环递归

   - 堆是向高地址扩展的数据结构，是使用链表相连的离散的内存空间，获得空间比较灵活，比较大，如果超过内存限制将抛出`OutOfMemory`

     > `-Xmx <size>` 堆最大值
     >
     > `-Xms <size>` 堆初始值
     >
     > `-Xmn <size>` 年轻代大小
     >
     > `-XXSurvivorRatio`年轻代中`Eden`区与`Survivor`区大小的比值

3. 存储内容

   - 虚拟机栈是线程私有的，存放局部变量表、方法参数等信息
   - 堆是线程共享的，几乎所有的对象都要在堆上分配内存空间，是垃圾回收的主要对象



## 常量池

1. ==Class文件常量池==

   class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。

2. ==运行时常量池==

   运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是`String.intern()`。

   > 在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是`StringTable`，以保证运行时常量池所引用的字符串与字符串常量池中是一致的

3. ==字符串常量池==

   字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中， 它是一个叫做`StringTable`的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个`Hashtable`。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”`interned string`”或通常所说的”进入了字符串常量池的字符串”。

   > JDK7时字符串常量池从方法区移到了堆中，由于`String.intern()`发生了改变，因此`String Pool`中也可以存放放于堆内的字符串对象的引用

4. ==基本类型包装类对象常量池==

   java中基本类型的包装类的大部分都实现了常量池技术，这些类是 Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外上面这5种整型的包装类也只是在对应值<=127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。



## JVM调优命令
