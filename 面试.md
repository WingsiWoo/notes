# 面试

## 计网

### HTTP1.0与HTTP1.1的对比

1. ==长连接（连接复用）==

   - HTTP1.0不支持长连接，每个HTTP请求都会创建一个新的TCP连接
   - HTTP1.1默认开启`Connection:Keep-Alive`开启长连接，并且HTTP1.1新增了请求的管道化处理，在一个TCP连接上可以传送多个HTTP请求和响应，在一定程度上减少了连接的创建的消耗和延迟，不过由于服务端仍然需要根据请求顺序响应，因此仍然没有解决HOLB队头阻塞问题

2. ==缓存处理==

   - HTTP1.0采用`Pragma+Expires`的方式进行缓存处理，`Expires`即把设定的过期时间和本地时间进行比较来确定缓存是否有效，如果本地时间不正确则可能达不到预期的效果
   - HTTP1.1采用`Cache-Control`来进行缓存控制

3. ==新增响应码==

   在HTTP1.1中新增了24个错误状态响应码，如`409(Conflict)`表示请求的资源 与资源的当前状态发生冲突;`410(Gone)`表示服务器上的某个资源被永久性的删除。

4. ==断点续传（分块传输）==

   - HTTP1.0不支持断点续传，传输的对象必须是完整的，如果传输中断了，下一次重新开始传输时就要从头开始传输
   - HTTP1.1支持断点续传，传输的对象可以不是完整的

5. ==请求部分对象==

   - HTTP1.0必须请求完整的对象，如果客户端只需要一部分数据，但服务端却只能传输完整的数据过来，就会造成带宽浪费
   - HTTP1.1可以通过设置range头域来请求一部分对象，返回码是`206(Partial Content)`，这样就方便了开发者自由的选择以便于充分利用带宽和连接。

6. ==Host头处理==

   - HTTP1.0认为每个IP地址只会有一个主机，因此请求URL中不传递host
   - 随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误(`400 Bad Request`)



### HTTP1.1与HTTP2.0的对比

1. ==二进制分帧==
   - HTTP1.1基于文本格式解析，但是由于文本格式的表现十分多样，因此要做到健壮性比较困难
   - HTTP2.0采用二进制分帧的方法，基于二进制解析，由于二进制只有0和1，因此要做到健壮性容易得多。并且在二进制分帧层上，HTTP2.0会把传输信息分为多个二进制帧
2. ==头部压缩==
   - HTTP1.x中，HTTP请求和响应都是由状态行、头部、消息主体三部分组成的。一般而言，消息主体都会经过压缩，或者本身传输的就是压缩过后的二进制文件。但状态行和头部却没有经过任何压缩，直接以纯文本传输。
   - 在HTTP2.0中，使用encoder来减少需要传输的header大小，通讯双方各自缓存一份头部字段表，既避免了重复header的传输，又减小了需要传输的大小。
3. ==多路复用（连接共享）==
   - 在HTTP1.1中，浏览器和客户端在同一时间、针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞，这也是为何一些站点会有多个静态资源CDN域名的原因之一。
   - HTTP2.0中，采用多路复用，多个HTTP Request可以共用一个TCP连接。归功于二进制分帧机制，HTTP2.0不再依赖多个TCP连接去实现多流并行，每个数据流都可以被拆分成很多个互不依赖的帧，可以乱序发送，然后在另一端重新组合。不仅可以减少消息交互往返的时间，还可以避免创建新连接造成的延迟，使得 TCP 的效率更高。
4. ==服务器推送==
   - HTTP1.x中，服务器发送数据都需要先收到客户端的请求
   - HTTP2.0中，添加了服务器推送的功能，服务器可以主动的向客户端推送数据而无需等待客户端的请求，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。服务器推送还有一个很大的优势：**可以缓存**。也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。