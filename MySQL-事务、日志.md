# MySQL-事务、日志

## 事务

**事务的ACID特性：原子性、一致性、隔离性、持久性**

事务的状态：

![image_1d7bvq3401fpe1eum1d7qkop1f479.png-69.6kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/1/169d7fd5bd4ce2f1~tplv-t2oaga2asx-watermark.awebp)



### 事务的基本操作

#### 开启事务

1. `BEGIN [WORK];`

2. `START TRANSACTION [修饰符];`

   `START TRANSACTION`语句和`BEGIN`语句有着相同的功效，都标志着开启一个事务。不过其后面可以跟随几个修饰符，用来设置事务的访问模式：

   - `READ ONLY`：标识当前事务是一个只读事务
   - `READ WRITE`：标识当前事务是一个读写事务，跟`READ ONLY`不能共存
   - `WITH CONSISTENT SNAPSHOT`：开启一致性读



#### 结束事务

1. 提交事务：`COMMIT`
2. 回滚事务：`ROLLBACK`



#### 保存点

`ROLLBACK`语句会使数据库状态直接恢复到事务执行之前的样子，而如果想要让事务回滚到指定的语句，就需要在那个语句上打上保存点，这样调用`ROLLBACK`语句时就会回滚到保存点，而不是直接回到原点

```sql
// 添加保存点
SAVEPOINT 保存点名称;
// 如果不带保存点名称的话则直接回滚到原点
ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;
// 删除保存点
RELEASE SAVEPOINT 保存点名称;
```



## redo日志

事务有一个特性是持久性，即对于一个已经提交的事务，无论发生什么问题，这个事务对数据库中作出的更改是永久的。

如果我们只在内存的`Buffer Pool`中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这就破坏了事务的持久性。

那么如何保证这个`持久性`呢？一个很简单的做法就是在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：

- 刷新一个完整的数据页太浪费了

  有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在`InnoDB`中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。

- 随机IO刷起来比较慢

  一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的`Buffer Pool`中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。

为了解决这些问题，redo日志就派上用场了。

redo日志会记录事务中对数据库的修改，这样当系统崩溃重启时，就可以根据redo日志去重做事务。

- `redo`日志占用的空间非常小

  存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的

- `redo`日志是顺序写入磁盘的

  在执行事务的过程中，每执行一条语句，就可能产生若干条`redo`日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。

> `redo`日志本质上只是记录了一下事务对数据库做了哪些修改。 



### redo日志格式

![image_1d36k7d3412oo1c0qcuuben12l79.png-31.3kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/4/1694892fdec61898~tplv-t2oaga2asx-watermark.awebp)

- `type`：该条`redo`日志的类型。

  在`MySQL 5.7.21`这个版本中，`InnoDB`一共为`redo`日志设计了53种不同的类型，稍后会详细介绍不同类型的`redo`日志。

- `space ID`：表空间ID。

- `page number`：页号。

- `data`：该条`redo`日志的具体内容。



### 简单的redo日志类型

在前面介绍InnoDB的记录行格式的时候说过，如果没有为某个表显式的定义主键，并且表中也没有定义Unique键，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键

为这个`row_id`隐藏列赋值的方式如下：

- 服务器会在内存中维护一个全局变量，每当向某个包含隐藏的`row_id`列的表中插入一条记录时，就会把该变量的值当作新记录的`row_id`列的值，并且把该变量自增1。
- 每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为`7`的页面中一个称之为`Max Row ID`的属性处（我们前边介绍表空间结构时详细说过）。
- 当系统启动时，会将上边提到的`Max Row ID`属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于`Max Row ID`属性值）。

这个`Max Row ID`属性占用的存储空间是8个字节，当某个事务向某个包含`row_id`隐藏列的表插入一条记录，并且为该记录分配的`row_id`值为256的倍数时，就会向系统表空间页号为7的页面的相应偏移量处写入8个字节的值。但是我们要知道，这个写入实际上是在`Buffer Pool`中完成的，我们需要为这个页面的修改记录一条`redo`日志，以便在系统崩溃后能将已经提交的该事务对该页面所做的修改恢复出来。这种情况下对页面的修改是极其简单的，**`redo`日志中只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥就好了。**

这种极其简单的redo日志成为物理日志，根据在页面中写入数据的多少划分了几种不同的redo日志类型：

- `MLOG_1BYTE`（`type`字段对应的十进制数字为`1`）：表示在页面的某个偏移量处写入1个字节的`redo`日志类型。

- `MLOG_2BYTE`（`type`字段对应的十进制数字为`2`）：表示在页面的某个偏移量处写入2个字节的`redo`日志类型。

- `MLOG_4BYTE`（`type`字段对应的十进制数字为`4`）：表示在页面的某个偏移量处写入4个字节的`redo`日志类型。

- `MLOG_8BYTE`（`type`字段对应的十进制数字为`8`）：表示在页面的某个偏移量处写入8个字节的`redo`日志类型。

- `MLOG_WRITE_STRING`（`type`字段对应的十进制数字为`30`）：表示在页面的某个偏移量处写入一串数据。因为不能确定写入的具体数据占用多少字节，所以需要在日志结构中添加一个`len`字段

  ![image_1d3fv8at819jh1m7m1sfb1donvmu16.png-47.2kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/4/1694892fdf3da823~tplv-t2oaga2asx-watermark.awebp)

> 上面提及的`Max Row ID`对应的redo日志类型就是`MLOG_8BYTE`，日志结构如下
>
> ![image_1d3fv01mv3jd7m719rpmn2jcsp.png-42.6kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/4/1694892fdf053082~tplv-t2oaga2asx-watermark.awebp)



### 复杂一些的redo日志类型

有时候执行一条语句，实际上会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的B+树）。以一条`INSERT`语句为例，它除了要向`B+`树的页面中插入数据，也可能更新系统数据`Max Row ID`的值，不过对于我们用户来说，平时更关心的是语句对`B+`树所做更新：

- 表中包含多少个索引，一条`INSERT`语句就可能更新多少棵`B+`树。
- 针对某一棵`B+`树来说，既可能更新叶子节点页面，也可能更新内节点页面，也可能创建新的页面（在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂，在内节点页面中添加`目录项记录`）。

在语句执行过程中，`INSERT`语句对所有页面的修改都得保存到`redo`日志中去。这句话说的比较轻巧，做起来可就比较麻烦了，比方说将记录插入到聚簇索引中时，如果定位到的叶子节点的剩余空间足够存储该记录时，那么只更新该叶子节点页面就好，那么只记录一条`MLOG_WRITE_STRING`类型的`redo`日志，表明在页面的某个偏移量处增加了哪些数据就好了么？别忘了一个数据页中除了存储实际的记录之后，还有什么`File Header`、`Page Header`、`Page Directory`等等部分（在唠叨数据页的章节有详细讲解），所以每往叶子节点代表的数据页里插入一条记录时，还有其他很多地方会跟着更新，比如说：

- 可能更新`Page Directory`中的槽信息。
- `Page Header`中的各种页面统计信息，比如`PAGE_N_DIR_SLOTS`表示的槽数量可能会更改，`PAGE_HEAP_TOP`代表的还未使用的空间最小地址可能会更改，`PAGE_N_HEAP`代表的本页面中的记录数量可能会更改，吧啦吧啦，各种信息都可能会被修改。
- 我们知道在数据页里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，还需要更新上一条记录的记录头信息中的`next_record`属性来维护这个单向链表。
- ……

![image_1d3gv4i7vtsirf81ikl1q2140n2g.png-67.2kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/4/1694892fdfa7d8ce~tplv-t2oaga2asx-watermark.awebp)

简单总结来说，就是一个修改语句实际上需要更改的地方非常多，如果只是使用上面简单的redo日志，可以有两种解决方案：

- 方案一：在每个修改的地方都记录一条`redo`日志。

  也就是如上图所示，有多少个加粗的块，就写多少条物理`redo`日志。这样子记录`redo`日志的缺点是显而易见的，因为被修改的地方是在太多了，可能记录的`redo`日志占用的空间都比整个页面占用的空间都多了～

- 方案二：将整个页面的`第一个被修改的字节`到`最后一个修改的字节`之间所有的数据当成是一条物理`redo`日志中的具体数据。

  从图中也可以看出来，`第一个被修改的字节`到`最后一个修改的字节`之间仍然有许多没有修改过的数据，我们把这些没有修改的数据也加入到`redo`日志中去岂不是太浪费了～

因此InnoDB提出了一些新的redo日志类型：

- `MLOG_REC_INSERT`（`type`字段对应的十进制数字为`9`）：表示插入一条使用非紧凑行格式的记录时的`redo`日志类型。
- `MLOG_COMP_REC_INSERT`（`type`字段对应的十进制数字为`38`）：表示插入一条使用紧凑行格式的记录时的`redo`日志类型。

> 小贴士： Redundant是一种比较原始的行格式，它就是非紧凑的。而Compact、Dynamic以及Compressed行格式是较新的行格式，它们是紧凑的（占用更小的存储空间）。

- `MLOG_COMP_PAGE_CREATE`（`type`字段对应的十进制数字为`58`）：表示创建一个存储紧凑行格式记录的页面的`redo`日志类型。
- `MLOG_COMP_REC_DELETE`（`type`字段对应的十进制数字为`42`）：表示删除一条使用紧凑行格式记录的`redo`日志类型。
- `MLOG_COMP_LIST_START_DELETE`（`type`字段对应的十进制数字为`44`）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的`redo`日志类型。
- `MLOG_COMP_LIST_END_DELETE`（`type`字段对应的十进制数字为`43`）：与`MLOG_COMP_LIST_START_DELETE`类型的`redo`日志呼应，表示删除一系列记录直到`MLOG_COMP_LIST_END_DELETE`类型的`redo`日志对应的记录为止。

> 小贴士： 我们前边唠叨InnoDB数据页格式的时候重点强调过，数据页中的记录是按照索引列大小的顺序组成单向链表的。有时候我们会有删除索引列的值在某个区间范围内的所有记录的需求，这时候如果我们每删除一条记录就写一条redo日志的话，效率可能有点低，所以提出`MLOG_COMP_LIST_START_DELETE`和`MLOG_COMP_LIST_END_DELETE`类型的redo日志，可以很大程度上减少redo日志的条数。

- `MLOG_ZIP_PAGE_COMPRESS`（`type`字段对应的十进制数字为`51`）：表示压缩一个数据页的`redo`日志类型。

这些类型的`redo`日志既包含`物理`层面的意思，也包含`逻辑`层面的意思，具体指：

- 物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。
- 逻辑层面看，在系统崩溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统崩溃前的样子。



## 事务隔离级别

MySQL是一个客户端/服务器架构的软件，对于服务器来说可能同时处理多个事务。但是如果想要完美的保持事务的隔离性的话，理论上字啊某个事物对某个数据进行访问时，其他食物应该进行排队，当该事务提交后，其他事务才可以继续访问这个数据。但是这样的话对性能影响太大，为了衡量性能与隔离性两者之间的平衡，提出了事务隔离级别的概念



### 事务并发执行遇到的问题

- 脏写

  如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写

  ![image_1d8nigfq618jd1cc56231rt0uq19.png-78.2kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/18/16a2f43405cb6e70~tplv-t2oaga2asx-watermark.awebp)

- 脏读

  如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了脏读

  ![image_1d8nn50kndkd8641epplvelhk9.png-91.8kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/18/16a2f79b4eacc05d~tplv-t2oaga2asx-watermark.awebp)

- 不可重复读

  如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了不可重复读

  ![image_1d8nk4k1e1mt51nsj1hg41cd7v5950.png-139.4kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/18/16a2f5b32bc1f76b~tplv-t2oaga2asx-watermark.awebp)

  > 不可重复读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读取不到之前读取过的记录

- 幻读

  如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读

  ![image_1d8nl564faluogc1eqn1am812v79.png-96.1kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/18/16a2f5b32d7b9ada~tplv-t2oaga2asx-watermark.awebp)

  > 幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。



### SQL标准中的四种隔离级别

以上一致性问题的严重程度为：脏写 > 脏读 > 不可重复读 > 幻读

|           隔离级别           | 脏读 | 不可重复读 | 幻读 |
| :--------------------------: | :--: | :--------: | :--: |
| 未提交读(`READ UNCOMMITTED`) |  √   |     √      |  √   |
|  已提交读(`READ COMMITTED`)  |  ✕   |     √      |  √   |
| 可重复读(`REPEATABLE READ`)  |  ✕   |     ✕      |  √   |
|   可串行化(`SERIALIZABLE`)   |  ✕   |     ✕      |  ✕   |

> 所有的隔离级别都不允许脏写的情况发生

MySQL默认的事务隔离级别为可重复读，可以通过下边的语句修改事务的隔离级别：

```sql
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;
```

设置事务的隔离级别的语句中，在`SET`关键字后可以放置`GLOBAL`关键字、`SESSION`关键字或者什么都不放，这样会对不同范围的事务产生不同的影响，具体如下：

- 使用`GLOBAL`关键字（在全局范围影响）：

  比方说这样：

  ```sql
  SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  ```

  则：

  - 只对执行完该语句之后产生的会话起作用。
  - 当前已经存在的会话无效。

- 使用`SESSION`关键字（在会话范围影响）：

  比方说这样：

  ```sql
  SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  ```

  则：

  - 对当前会话的所有后续的事务有效
  - 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务。
  - 如果在事务之间执行，则对后续的事务有效。

- 上述两个关键字都不用（只对执行语句后的下一个事务产生影响）：

  比方说这样：

  ```sql
  SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  ```

  则：

  - 只对当前会话中下一个即将开启的事务有效。
  - 下一个事务执行完后，后续事务将恢复到之前的隔离级别。
  - 该语句不能在已经开启的事务中间执行，会报错的。



### MVCC原理

#### 版本链

对于使用`InnoDB`存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（`row_id`并不是必要的，我们创建的表中有主键或者非NULL的UNIQUE键时都不会包含`row_id`列）：

- `trx_id`：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的`事务id`赋值给`trx_id`隐藏列。
- `roll_pointer`：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到`undo日志`中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。

![image_1d8oab1ubb7v5f41j2pai21co19.png-22.4kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/19/16a337f526c95a9e~tplv-t2oaga2asx-watermark.awebp)

> 实际上`insert undo`只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的`Undo Log Segment`也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。虽然真正的`insert undo`日志占用的存储空间被释放了，但是`roll_pointer`的值并不会被清除，`roll_pointer`属性占用7个字节，第一个比特位就标记着它指向的undo日志的类型，如果该比特位的值为1时，就代表着它指向的undo日志类型为`insert undo`。

每次对记录进行改动，都会记录一条`undo日志`，每条`undo日志`也都有一个`roll_pointer`属性（`INSERT`操作对应的`undo日志`没有该属性，因为该记录并没有更早的版本），可以将这些`undo日志`都连起来，串成一个链表

对该记录每次更新后，都会将旧值放到一条`undo日志`中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被`roll_pointer`属性连接成一个链表，我们把这个链表称之为`版本链`，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的`事务id`，这个信息很重要，我们稍后就会用到。



#### ReadView

1. 对于使用`READ UNCOMMITTED`隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了
2. 对于使用`SERIALIZABLE`隔离级别的事务来说，需要通过加锁的方式来访问记录
3. 对于使用`READ COMMITTED`和`REPEATABLE READ`隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的

核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。为此，`InnoDB`提出了一个`ReadView`的概念，这个`ReadView`中主要包含4个比较重要的内容：

- `m_ids`：表示在生成`ReadView`时当前系统中活跃的读写事务的`事务id`列表。

- `min_trx_id`：表示在生成`ReadView`时当前系统中活跃的读写事务中最小的`事务id`，也就是`m_ids`中的最小值。

- `max_trx_id`：表示生成`ReadView`时系统中应该分配给下一个事务的`id`值。

  > 注意`max_trx_id`并不是`m_ids`中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成`ReadView`时，`m_ids`就包括1和2，`min_trx_id`的值就是1，`max_trx_id`的值就是4。

- `creator_trx_id`：表示生成该`ReadView`的事务的`事务id`。

  > 只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。

有了这个`ReadView`，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

- 如果被访问版本的`trx_id`属性值与`ReadView`中的`creator_trx_id`值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值小于`ReadView`中的`min_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`前已经提交，所以该版本可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值大于或等于`ReadView`中的`max_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`后才开启，所以该版本不可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值在`ReadView`的`min_trx_id`和`max_trx_id`之间，那就需要判断一下`trx_id`属性值是不是在`m_ids`列表中，如果在，说明创建`ReadView`时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建`ReadView`时生成该版本的事务已经被提交，该版本可以被访问。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。



#### READ COMMITTED —— 每次读取数据前都生成一个ReadView



#### REPEATABLE READ —— 在第一次读取数据时生成一个ReadView



> 我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的

























