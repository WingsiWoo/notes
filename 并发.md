# 并发

众所周知，CPU、内存、I/O设备的速度是有极大差异的，为了合理利用CPU的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：

- CPU增加了缓存，以均衡与内存的速度差异 → 导致**可见性**问题
- 操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异 → 导致**原子性**问题
- 编译程序优化指令执行次序，使得缓存能够得到更加合理的利用 → 导致**有序性**问题



## 并发三要素

### 可见性-CPU缓存引起

当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值，这就是可见性。

在多线程环境下，每个线程都有自己独立的工作内存，工作内存中的数据其他线程是不可见的。线程对数据的操作，都是将数据从主存中拷贝至自己的工作内存中进行操作，然后才将操作后的数据写回主存中。

这样就很容易引发一个问题：

假设线程A从主存中读取了变量X，修改后并未及时地将数据写回主存。此时线程B也从主存中读取变量X，就会发现线程B读取的变量X是原来的值，而不是线程A修改后的值。这种工作内存与主存同步延迟现象造成了可见性问题。



### 原子性-分时复用引起

只有对基本数据类型的变量的读取和赋值操作是原子性操作

> 原子性：不可中断，要么执行，要么不执行
>
> 变量之间的相互赋值不是原子操作

对于一个x++操作，其实际上分为三步：

1. 从主存中读取x的值到工作内存中，这一步是一个原子操作
2. 将获取到的x值进行+1运算
3. 把修改后的x的值写回内存

这三个操作并不保证一定会全部都执行，因此x++不是一个原子性操作。

原子性在多线程环境下引起的问题很常见：

假设银行A向B转账的步骤有以下两步：

1. 账户A扣钱
2. 账户B加钱

假设步骤1执行后操作终止了，就会出现钱已经扣了，但是并没有人收到钱的情况，从而导致数据错误

> 对于32位系统来说，`long`类型数据和`double`类型数据，它们的读写是非原子性的。
>
> 但是对于基本数据类型`byte`、`short`、`int`、`float`、`boolean`、`char`读写是原子操作



### 有序性-重排序引起

计算机的处理器为了提升代码的执行效率，会在保证执行结果一致的前提下对指令进行重排序。重排序分三种类型：

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序。现代处理器采用了指令级并行技术`（Instruction-Level Parallelism， ILP）`来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：

![img](https://pdai.tech/_images/jvm/java-jmm-3.png)

在单线程情况下，指令重排不会影响程序执行结果，却会影响到多线程并发执行的正确性。



## Java解决并发——JMM

### volatile

#### 防止指令重排序

实例化一个对象其实可以分为三个步骤：

1. 分配内存空间
2. 初始化对象
3. 将内存空间的地址赋值给对应的引用

但是上面的三个步骤不一定按照这个顺序执行。在多线程环境下，如果步骤3在步骤2之前执行，可能会提前把一个未初始化的对象引用暴露出来，从而导致不可预料的结果。



#### 实现可见性

可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。

`volatile`修饰的变量在每次被线程访问时，都强迫从主内存中读该变量的值，当该变量发生变化时，又会强迫将最新的值刷新到主内存，从而保证在任何时刻不同的线程总能看到该变量的最新值。



#### 保证单次读/写的原子性

1. 共享的`long`和`double`变量为什么要用`volatile`？

   `long`和`double`两种数据类型的操作可以分为高32位和低32位两部分，因此普通的`long`和`double`类型读/写可能不是原子的。

2. i++为什么不能保证原子性？

   i++本质上是读、写两次操作（把i变量从主存读入到线程的工作内存中，修改后再写回到主存中）。标题都写了，volatile保证的是单次读/写的原子性，所以自然不能保证i++的原子性



#### 配合双重检查锁

1. 实现单例模式时，如果没有加上双重检查锁：

   ```java
   public class Singleton {
       private static Singleton uniqueSingleton;
   
       private Singleton() {
       }
   
       public Singleton getInstance() {
           if (null == uniqueSingleton) {
               uniqueSingleton = new Singleton();
           }
           return uniqueSingleton;
       }
   }
   ```

   在多线程情况下可能会导致`uniqueSingleton`有多个实例，这样就不是真正的单例了

   ![image-20211125172923290](https://tva1.sinaimg.cn/large/008i3skNgy1gwriyg74j9j30ea06vq36.jpg)

2. 如果直接在方法头上加锁，可以解决这个问题。但是这样会导致很大的性能开销，并且加锁其实只需要在第一次初始化的时候需要使用，之后对`getInstance()`的调用都没有必要进行加锁

3. 不带`volatile`的**错误**双重检查锁

   ```java
   public class Singleton {
       private static Singleton uniqueSingleton;
   
       private Singleton() {
       }
   
       public Singleton getInstance() {
           if (null == uniqueSingleton) {
               synchronized (Singleton.class) {
                   if (null == uniqueSingleton) {
                       uniqueSingleton = new Singleton();   // error
                   }
               }
           }
           return uniqueSingleton;
       }
   }
   ```

   `uniqueSingleton`没有加上`volatile`关键字，意味着它的实例化仍然可以进行指令重排，如果出现以下情况：

   ![image-20211125174311180](https://tva1.sinaimg.cn/large/008i3skNgy1gwrjcrvtsxj30j608saas.jpg)

   这种情况下，线程B访问`uniqueSingleton`得到的就是一个初始化未完成的对象

4. 带上`volatile`的**正确**双重检查锁

   为了解决第三点的问题，为`uniqueSingleton`加上`volatile`关键字就好了，保证所有的写操作都在读操作之前

   ```java
   public class Singleton {
       private volatile static Singleton uniqueSingleton;
   
       private Singleton() {
       }
   
       public Singleton getInstance() {
           if (null == uniqueSingleton) {
               synchronized (Singleton.class) {
                   if (null == uniqueSingleton) {
                       uniqueSingleton = new Singleton();
                   }
               }
           }
           return uniqueSingleton;
       }
   }
   ```





### synchronized

#### 可重入原理——加锁次数计数器

与`synchronized`相关的两个字节码指令：`monitorenter`、`monitorexit`。这两个指令分别会使锁计数器+1和-1。

每一个对象在同一时间只与一个`monitor`(锁)相关联，而一个`monitor`在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的`Monitor`锁的所有权的时候，`monitorenter`指令会发生如下3中情况之一：

- `monitor`计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待
- 如果这个`monitor`已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加
- 这把锁已经被别的线程获取了，等待锁释放

![img](https://pdai.tech/_images/thread/java-thread-x-key-schronized-2.png)



#### 锁的类型

在JVM中`monitorenter`和`monitorexit`字节码依赖于底层的操作系统的`Mutex Lock`来实现的，使用`Mutex Lock`需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。

然而在现实的大部分情况下，同步方法是运行在单线程环境（无锁竞争环境）下的，如果每次都调用`Mutex Lock`，那么将严重影响程序性能。不过在JDK6中对锁的实现引入了大量的优化，如锁粗化、锁消除、轻量级锁、偏向锁、适应性自旋等技术来减少锁操作的开销

在Java SE 1.6里`Synchronied`同步锁，一共有四种状态：`无锁`、`偏向锁`、`轻量级锁`、`重量级锁`，它会随着竞争情况逐渐升级。**锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。**

> 锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)



#### 锁的优化

##### 自旋锁

在没有加入锁优化时，在多线程竞争锁时，当一个线程获得锁后，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在原地自旋等待，并不放弃CPU的执行时间。为了让线程等待，只需要让线程执行一个忙循环（自旋），这就是自旋锁的由来。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190808204844232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbjE5OTU=,size_16,color_FFFFFF,t_70)



##### 自适应自旋锁

自旋锁有一个问题：其虽然避免了线程切换的开销，如果锁被占用的时间很短，自旋的效果就很好；但如果锁被占用的时间很长，自旋期间一直占用处理器时间，反而得不偿失了

因此引入了自适应自旋锁，这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上自旋的时间及锁的拥有者的状态来决定的。

- 如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性较大，会自动增加等待时间
- 如果对于某个锁，自旋很少成功获取到，那么之后可能会省略自旋过程，以避免浪费处理器资源。



##### 锁消除

锁消除是指虚拟机即时编译器运行时，对一些代码上要求同步，但是实际上不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。



##### 锁粗化

在加同步锁时，应该尽可能的将同步块的作用范围限制到尽量小的范围（只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早拿到锁）

但是如果存在一连串的一系列操作都对同一个对象反复加锁和解锁，或者加锁操作出现在循环中，那么即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能浪费。

JVM会检测到这样一连串地操作都是对同一个对象加锁，那么JVM会将加锁同步地范围扩展(粗化)到整个一系列操作的外部，这就是锁粗化



##### 轻量级锁

在对象头中(`Object Header`)存在两部分：

- 一部分存储对象自身的运行时数据，`HashCode`、`GC Age`、`锁标记位`、`是否为偏向锁`。等。一般为32位或者64位(视操作系统位数定)。官方称之为`Mark Word`，它是实现轻量级锁和偏向锁的关键。 
- 另外一部分存储的是指向方法区对象类型数据的指针(`Klass Point`)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。

![img](https://pica.zhimg.com/80/v2-5171320da7ba20a89cc4b1decb90fed4_720w.jpg?source=1940ef5c)



在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(`Lock Record`)的空间，用于存储锁对象目前的`Mark Word`的拷贝(JVM会将对象头中的`Mark Word`拷贝到锁记录中，官方称为`Displaced Mark Ward`)这个时候线程堆栈与对象头的状态如图：

![img](https://pdai.tech/_images/thread/java-thread-x-key-schronized-5.png)

如上图所示：如果当前对象没有被锁定，那么锁标志位位01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录`Lock Record`的空间用于存储锁对象目前的`Mark Word`的拷贝。

 然后，虚拟机使用CAS操作将标记字段`Mark Word`拷贝到锁记录中，并且将`Mark Word`更新为指向`Lock Record`的指针。如果更新成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位更新为(`Mark Word`中最后的2bit)**00**，即表示此对象处于轻量级锁定状态

![img](https://pdai.tech/_images/thread/java-thread-x-key-schronized-6.png)

如果这个更新操作失败，JVM会检查当前的`Mark Word`中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，**如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀为重量级锁，没有获得锁的线程会被阻塞**。此时，锁的标志位为**10**，`Mark Word`中存储的时指向重量级锁的指针。

 轻量级解锁时，会使用原子的CAS操作将`Displaced Mark Word`替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：

![img](https://pdai.tech/_images/thread/java-thread-x-key-schronized-7.png)



##### 偏向锁

在部分环境下，锁不仅不存在多线程竞争，而且总是有由同一个线程多次获取，这种情况下多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。

为解决这一问题，JDK6引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单地测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。

> 通俗的讲，偏向锁就是在运行过程中，对象的锁偏向某个线程。即在开启偏向锁机制的情况下，某个线程获得锁，当该线程下次再想要获得锁时，不需要再获得锁（即忽略`synchronized`关键词），直接就可以执行同步代码，比较适合竞争较少的情况。

![img](https://pdai.tech/_images/thread/java-thread-x-key-schronized-8.png)

1. 初始时对象的`Mark Work`位为01，表示对象处于可偏向的状态，并且`ThreadID`为0，该对象为未偏向但是可偏向的对象（`biasable&unbiased`），可以加上偏向锁进入2。（分支-如果偏向锁可用）

   如果一个线程试图获取锁并且`ThreadID`不等于自己ID时，由于锁竞争，此时应该撤销偏向锁并进入4（分支-如果偏向锁不可用）

2. 线程尝试用CAS操作把自己的`ThreadID`放置到`Mark Word`中相应的位置，如果成功则进入3，否则进入4

3. 进入到这一步表示当前没有锁竞争，此时`ThreadID`为获取到锁的线程的ID，对象处于已偏向并锁定状态（`biasable&biased`）

4. 当线程执行CAS失败，表示另一个线程正在竞争该对象上的锁。当到达全局安全点时（cpu没有正在执行的字节）获得偏向锁的线程将被挂起，撤销偏向（偏向位置0）。

   如果这个线程已经死了，则把对象恢复到未锁定状态（标志位改为01）

   如果线程还活着，则把偏向锁置0，变成轻量级锁（标志位改为00），释放被阻塞的线程，进入到轻量级锁的执行路径中，同时被撤销偏向锁的线程继续往下执行。

5. 运行同步代码块

![image-20211125215936632](https://tva1.sinaimg.cn/large/008i3skNgy1gwrqrm1r0cj30u017rdmb.jpg)



 偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。

![img](https://pdai.tech/_images/thread/java-thread-x-key-schronized-9.png)



#### 锁的优缺点对比

![image-20211125221725820](https://tva1.sinaimg.cn/large/008i3skNgy1gwrra3wmx9j30i307kdgu.jpg)



### final

```java
public class FinalDemo {
    private int a;  //普通域
    private final int b; //final域
    private static FinalDemo finalDemo;

    public FinalDemo() {
        a = 1; // 1. 写普通域
        b = 2; // 2. 写final域
    }

    public static void writer() {
        finalDemo = new FinalDemo();
    }

    public static void reader() {
        FinalDemo demo = finalDemo; // 3.读对象引用
        int a = demo.a;    //4.读普通域
        int b = demo.b;    //5.读final域
    }
}
  
```

假设线程A在执行`writer()`方法，线程B执行`reader()`方法。



#### 写final域重排序规则

- JMM禁止编译器把`final`域的写重排序到构造函数之外；

- 编译器会在`final`域写之后，构造函数`return`之前，插入一个`storestore`屏障。这个屏障可以禁止处理器把`final`域的写重排序到构造函数之外。
- 在构造函数内对一个`final`修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。（即操作2一定在操作3之前）

```java
public class FinalDemo {
    private int a;  //普通域
    private final int b; //final域
    private static FinalDemo finalDemo;

    public FinalDemo() {
        a = 1; // 1. 写普通域
        b = 2; // 2. 写final域
    }

    public static void writer() {
        finalDemo = new FinalDemo();
    }

    public static void reader() {
        FinalDemo demo = finalDemo; // 3.读对象引用
        int a = demo.a;    //4.读普通域
        int b = demo.b;    //5.读final域
    }
}

```

假设线程A在执行`writer()`方法，线程B在执行`reader()`方法

由于变量a是普通变量，变量b是`final`变量，并且二者之间没有数据依赖性，所以写普通域a这一条指令可能会被重排到构造函数之外，这样线程B就有可能读取到的是变量a初始化之前的值（零值）。

因此，写`final`域的重排序规则可以确保在对象引用为任意线程可见之前，对象的`final`域已经被正确初始化过了。



#### 读final域重排序规则

初次读对象引用和初次读该对象包含的`final`域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读`final`域操作的前面插入一个`LoadLoad`屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。

`read()`方法主要包含了以下操作：

- 初次读引用变量`finalDemo`
- 初次读引用变量`finalDemo`的普通域a
- 初次读引用变量`finalDemo`的final域b

假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图：

![img](https://pdai.tech/_images/thread/java-thread-x-key-final-2.png)

读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而`final`域的读操作就“限定”了**在读`final`域变量前已经读到了该对象的引用**，从而就可以避免这种情况。

读`final`域的重排序规则可以确保：在读一个对象的`final`域之前，一定会先读这个包含这个`final`域的对象的引用。



#### 限制条件和局限性

1. 当声明一个`final`成员时，必须在构造函数退出前设置它的值

2. 将指向对象的成员声明为`final`只能将该引用设为不可变的，而非所指的对象

   ```java
   // 以下操作合法
   private final List myList = new ArrayList();
   myList.add("Hello");
   
   // 以下操作不合法
   myList = new ArrayList();
   myList = someOtherList;
   ```

   

### Happens-Before

从JDK5开始，Java使用新的JSR-133内存模型，提供了`Happens-Before`原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据。

1. 程序顺序原则

   在一个线程内。必须保证语义串行性，即：代码顺序执行

2. 锁规则

   解锁操作必然发生在后续的同一个锁的加锁之前

3. `volatile`规则

   `volatile`变量的写，先发生于读

   > `volatile`变量在每次被线程访问时吗，都强迫从主内存中读该变量的值
   >
   > 当该变量发生变化时，又会强迫将最新的值刷新到主内存
   >
   > 从而保证在任何时刻不同的线程总能看到该变量的最新值

4. 线程加入规则

   `Thread`对象的结束线性发生于`join()`方法返回

5. 线程启动规则

   `Thread`对象的`start()`方法先行发生于此线程的每一个动作

6. 传递规则

   A先于B，B先于C，则A必定先于C

7. 线程终止规则

   线程的所有操作先于线程的终结

8. 线程中断规则

   对线程`interrupt()`方法的调用先行发生于被中断线程的代码检测到中断事件的发生

9. 对象终结规则

   对象的构造函数执行，结束先于`finalize()`方法



#### Java中的有序性

通常在Java中，可以采取`volatile`关键字来保证一定的有序性。另外也可以采取使用`synchronized`和`Lock`来保证有序性。

> `synchronized`和`Lock`保证每个时刻，都只有一个线程执行代码块，将多线程转化为串行。自然保证了有序性。

另外，Java内存模型(JMM)具备一些先天的有序性，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 `happens-before` 原则。

如果两个操作的执行次序无法从`happens-before`原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

**为什么JMM具备先天的有序性？**

在JMM内存模型中，每个线程都有自己独立的工作内存。线程对变量信息的所有操作，都是在各自独立的工作内存中完成的，而不是直接对主存进行操作。并且每个线程都不能访问其他线程的工作内存。



### 共享数据安全强度

#### 不可变

不可变的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确的构建出来，永远也不会看到它在多个线程之中处于不一致的状态。

> 多线程环境下，应当尽量使对象成为不可变，来满足线程安全

不可变的类型：

- `final`关键字修饰的基本数据类型

- `String`

- 枚举类型

- `Number`部分子类：比如`Long`、`Double`等数值包装类型，`BigInteger`、`BigDecimal`等大数据类型。但`AtomicInteger`、`AtomicLong`是可变的

- 通过`Collections.unmodifiableXXX()`获取的不可变集合

  > 该方法会对原始的集合进行拷贝，并重写所有对集合进行修改的方法，直接抛出`UnsupportedOperationException`异常



#### 绝对线程安全

不管运行时环境如何，调用者都不需要任何额外的同步措施。



#### 相对线程安全

相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

在 Java 语言中，大部分的线程安全类都属于这种类型，例如 `Vector`、`HashTable`、`Collections` 的 `synchronizedCollection()` 方法包装的集合等。

例如对于`Vector`，假设删除线程先删除了`Vector`的一个元素，而获取线程试图访问这个已经被删除的元素，那么就会抛出`ArrayIndexOutOfBoundsException`异常



#### 线程兼容

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 `Vector` 和 `HashTable` 相对应的集合类 `ArrayList` 和 `HashMap` 等。



#### 线程对立

线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。



### 线程安全实现方法

#### 互斥同步

互斥同步即控制多个线程对共享资源的访问，当一个线程正在访问共享资源时，其余想要访问该共享资源的线程就要等待。Java提供了两种锁机制来控制多个线程对共享资源的互斥访问，一个是JVM实现的`synchronized`，另一个是JDK实现的`ReentrantLock`



##### synchronized

使用`synchronized`要注意锁的对象，假如使用的是`synchronized(this)`来锁住方法`func1()`，按照如下代码：

```java
SynchronizedExample e1 = new SynchronizedExample();
ExecutorService executorService = Executors.newCachedThreadPool();
executorService.execute(() -> e1.func1());
executorService.execute(() -> e1.func1());
```

由于使用的都是对象e1的锁，所以这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程必须等待。

```java
 SynchronizedExample e1 = new SynchronizedExample();
 SynchronizedExample e2 = new SynchronizedExample();
 ExecutorService executorService = Executors.newCachedThreadPool();
 executorService.execute(() -> e1.func1());
 executorService.execute(() -> e2.func1());
```

这两个线程调用了不同对象的`fun1()`方法，拿到的是不同对象的锁，因此这两个线程不需要同步。

> 如果使用的是`synchronized(类.class)`，那么以上两种写法都会进行同步。
>
> `synchronized`关键字修饰静态方法也是作用于整个类（因为静态方法是属于类的）



##### ReentrantLock

`ReentrantLock`是`java.util.concurrent(J.U.C)`包中的锁

```java
public class LockExample {

    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();
        try {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}

```



##### 对比

|                |                         synchronized                         |                        ReentrantLock                        |
| :------------: | :----------------------------------------------------------: | :---------------------------------------------------------: |
|    锁的实现    |                             JVM                              |                             JDK                             |
|      使用      |         无需手动释放，系统会自动让线程释放对锁的占用         |             需要用户手动释放，否则可能导致死锁              |
|   等待可中断   |                           不可中断                           |                           可中断                            |
|     公平锁     |                            非公平                            |          默认为非公平，调用构造方法时可设置为公平           |
| 锁绑定多个条件 |                           不可绑定                           |                可以同时绑定多个Condition对象                |
|    锁的对象    | 锁的是对象，保存在对象头里，根据对象头数据来标识是否有线程获得锁/争抢锁 | 锁的是线程，根据进入的线程和int类型的state标识锁的获得/争抢 |

> 1. `synchronized`是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； `ReentrantLock`则可以中断，可通过`trylock(long timeout,TimeUnit unit)`设置超时方法或者将`lockInterruptibly()`放到代码块中，调用`interrupt`方法进行中断。
> 2. `ReentrantLock`通过绑定`Condition`结合`await()/singal()`方法实现线程的精确唤醒，而不是像`synchronized`通过`Object`类的`wait()/notify()/notifyAll()`方法要么随机唤醒一个线程要么唤醒全部线程。



#### 非阻塞同步

互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。

互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。



##### CAS（Compare AND Swap）

CAS（Compare AND Swap），即比较再交换。是一个乐观锁，它假设现在没有冲突，尝试去完成某项操作，如果因为冲突而失败就一直重试，直到成功。需要有3个操作数：

- 内存地址V
- 旧的预期值A
- 即将要更新的目标值B

CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则什么都不做，这整个比较并替换的操作是一个原子操作（靠硬件来完成）。

> 原子操作类如`AtomicInteger`的`compareAndSet()`方法和`getAndIncrement()`方法底层都使用了`Unsafe`类的CAS操作



**ABA问题**

CAS存在一个问题：如果一个值原来是A，变成了B，又变回A，那么CAS比较之后就会认为值没有发生变化，于是进行修改。但实际上这个值已经发生变化了。

ABA问题的解决思路就是使用版本号：在变量面前追加上版本号，每次变量更新时把版本号+1，那么A→B→A就变成了1A→2B→3A，CAS就能发现值的变化了。

从Java 1.5开始，JDK的`Atomic`包里提供了一个类`AtomicStampedReference`来解决ABA问题。这个类的`compareAndSet`方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。



#### 无同步方案

要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。



##### 栈封闭

多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为**局部变量存储在虚拟机栈中，属于线程私有的**。



##### 线程本地存储

如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

可以使用`java.lang.ThreadLocal`类来实现线程本地存储功能：

每个`Thread`都有一个`ThreadLocal.ThreadLocalMap`对象：

```java
ThreadLocal.ThreadLocalMap threadLocals = null;
```

当调用`ThreadLocal.set(T value)`方法时，会先获取当前线程的`ThreadLocalMap`对象，然后将`ThreadLocal-value`键值对插入到该Map中。也就是说，每个线程都会把自己操作的`ThreadLocal`存储在自己的Map中。

> `ThreadLocal` 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。

在一些场景 (尤其是使用线程池) 下，由于 `ThreadLocal.ThreadLocalMap` 的底层数据结构导致 `ThreadLocal` 有内存泄漏的情况，应该尽可能在每次使用 `ThreadLocal` 后手动调用 `remove()`，以避免出现 `ThreadLocal` 经典的内存泄漏甚至是造成自身业务混乱的风险。



##### 可重入代码

这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。

可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。



## ReentrantLock源码解析

`ReentrantLock`共有三个内部类，关系如下图：

![image](https://pdai.tech/_images/thread/java-thread-x-juc-reentrantlock-1.png)

`ReentrantLock`只有一个属性`Sync`（其实就是真正的锁）



### 构造方法

`ReentrantLock`默认为非公平锁，可以通过调用构造方法时传入true来创建公平锁

```java
public ReentrantLock() {
    sync = new NonfairSync();
}

public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```



### Sync

```java
abstract static class Sync extends AbstractQueuedSynchronizer {
    // 获取锁的方法，子类必须实现
    abstract void lock();

    final boolean nonfairTryAcquire(int acquires) {...}

    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }

    protected final boolean isHeldExclusively() {
        // While we must in general read state before owner,
        // we don't need to do so to check if current thread is owner
        return getExclusiveOwnerThread() == Thread.currentThread();
    }

    final ConditionObject newCondition() {
        return new ConditionObject();
    }

    // Methods relayed from outer class

    final Thread getOwner() {
        return getState() == 0 ? null : getExclusiveOwnerThread();
    }

    final int getHoldCount() {
        return isHeldExclusively() ? getState() : 0;
    }

    final boolean isLocked() {
        return getState() != 0;
    }

    /**
     * Reconstitutes the instance from a stream (that is, deserializes it).
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();
        setState(0); // reset to unlocked state
    }
}
```



### NonfairSync

```java
static final class NonfairSync extends Sync {
    final void lock() {
       // 如果state状态为0，说明当前没有线程竞争锁，CAS成功，获取锁成功
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
           // 锁已经被占用(state状态不为0)，或CAS失败，则以独占模式获取对象，忽略中断
            acquire(1);
    }

    protected final boolean tryAcquire(int acquires) {
       // 调用在Sync中的非公平锁获取锁方法
        return nonfairTryAcquire(acquires);
    }
}

// from AbstractQueuedSynchronizer
public final void acquire(int arg) {
  if (!tryAcquire(arg) &&
      // 如果tryAcquire方法返回false，即获取锁失败，则进入队列等待
      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
    // 获取锁失败就线程阻塞
    selfInterrupt();
}


// from Sync
final boolean nonfairTryAcquire(int acquires) {
  final Thread current = Thread.currentThread();
  int c = getState();
  // 如果state状态为0说明当前没有锁竞争，尝试CAS获取
  if (c == 0) {
    if (compareAndSetState(0, acquires)) {
      setExclusiveOwnerThread(current);
      return true;
    }
  }
  // 当前线程已经获取了该锁
  else if (current == getExclusiveOwnerThread()) {
    // 增加可重入次数
    int nextc = c + acquires;
    if (nextc < 0) // overflow
      throw new Error("Maximum lock count exceeded");
    setState(nextc);
    return true;
  }
  return false;
}
```



#### 锁获取过程

A线程准备进去获取锁，首先判断了一下state状态，发现是0，所以可以CAS成功，并且修改了当前持有锁的线程为自己。

![img](https://pic3.zhimg.com/80/v2-e95055fb06912adbd0f13e2d9b3e128a_720w.jpg)

这个时候B线程也过来了，也是一上来先去判断了一下state状态，发现是1，CAS失败，并且当前加锁线程不是自己，于是只能进入等待队列休眠等待唤醒

![img](https://pic1.zhimg.com/80/v2-a55d05b65f58984e5632b4ab18c7fcb8_720w.jpg)

线程A释放锁，把state修改回0，恢复加锁线程的信息，并唤醒等待队列的队头线程B

![img](https://pic2.zhimg.com/80/v2-9b55c499d1d012e56bb124d52ad6b469_720w.jpg)

这时线程C到达，发现state为0，于是CAS修改为1，还修改了当前持有锁的线程为自己。（抢占锁）

B线程被A唤醒准备去获取锁，发现state居然是1，CAS就失败了，只能继续回去等待队列

![img](https://pic3.zhimg.com/80/v2-c2109ccde8193517f686d1aeda955eca_720w.jpg)

以上就是一个非公平锁的争抢过程：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。

- 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高些，CPU也不必唤醒所有线程，会减少唤醒线程的数量
- 缺点：可能会导致像上面B线程这种长时间获取不到锁的情况，导致饥饿现象



### FairSync

```java
static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;

    final void lock() {
        acquire(1);
    }
  
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
           // hasQueuedPredecessors() 方法为判断等待队列中是否有队列在等待
            if (!hasQueuedPredecessors() &&
                // 如果没有队列在等待，那么当前线程可以尝试CAS修改锁状态获取锁
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
      // 当前线程为已经占有锁
        else if (current == getExclusiveOwnerThread()) {
          // 在呢个价可重入次数
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}


 // from AbstractQueuedSynchronizer
public final void acquire(int arg) {
  if (!tryAcquire(arg) &&
      // 如果tryAcquire方法返回false，即获取锁失败，则进入队列等待
      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
    // 获取锁失败就线程阻塞
    selfInterrupt();
}  
```



#### 锁获取过程

线A现在想要获得锁，先去判断下state，发现也是0，去看了看队列，自己居然是第一位，果断修改了持有线程为自己。

![img](https://pic1.zhimg.com/80/v2-dcdc7a00cf64cdb961063b19a2fd12dc_720w.jpg)

线程b过来了，去判断一下state，嗯哼？居然是state=1，那cas就失败了呀，所以只能乖乖去排队了。

![img](https://pic3.zhimg.com/80/v2-89e7b1f27f62fd035173ed87c4046f7e_720w.jpg)

线程A暖男来了，持有没多久就释放了，改掉了所有的状态就去唤醒线程B了，这个时候线程C进来了，但是他先判断了下state发现是0，以为有戏，然后去看了看队列，发现前面有人了，作为新时代的良好市民，果断排队去了。

![img](https://pic4.zhimg.com/80/v2-7a280921de91d6d5d89f027ec4faa3b3_720w.jpg)

线程B得到A的召唤，去判断state了，发现值为0，自己也是队列的第一位，那很香呀，可以得到了。

![img](https://pic2.zhimg.com/80/v2-84816ac8172eeb9519bd783334a99815_720w.jpg)

以上就是公平锁的争抢过程：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。

- 优点：所有的线程都能得到资源，不会饿死在队列中。
- 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

> 即使在锁状态state为0的情况下，公平锁也要先检查队列中是否有线程，如果有，则要把自己挂起去队列中等待；但非公平锁则可以直接获取锁。在这种情况下，公平锁比非公平锁多了一次阻塞与唤醒的操作
>
> **线程切换的开销**，其实就是非公平锁效率高于公平锁的原因，因为**非公平锁减少了线程挂起的几率**，后来的线程有一定几率逃离被挂起的开销。



## 线程基础

### 线程状态转换

![image](https://pdai.tech/_images/pics/ace830df-9919-48ca-91b5-60b193f593d2.png)

- 新建（`New`）：创建后还未启动，调用`Thread.start()`启动后线程转换为`Runnable`状态

- 可运行（`Runnable`）：可能正在运行，也可能正在等待CPU时间片。包含了操作系统线程状态中的运行状态（`Running`）和就绪状态（`Ready`）

- 阻塞（`Blocking`）：等待获取一个排它锁，如果其线程释放了锁就会结束此状态

- 无限期等待（`Waiting`）：等待其他线程显式地唤醒，否则不会被分配CPU时间片

  |                进入方法                |              退出方法              |
  | :------------------------------------: | :--------------------------------: |
  | 没有设置Timeout参数的Object.wait()方法 | Object.notify()/Object.notifyAll() |
  | 没有设置Timeout参数的Thread.join()方法 |        被调用的线程执行完毕        |
  |         LockSupport.park()方法         |                 -                  |

- 限期等待（`Timed Waiting`）：无需等待其他线程显式地唤醒，在一定时间后会被系统自动唤醒

  |              进入方法              |                  退出方法                   |
  | :--------------------------------: | :-----------------------------------------: |
  |           Thread.sleep()           |                  时间结束                   |
  | 设置Timeout参数的Object.wait()方法 | 时间结束/Object.notify()/Object.notifyAll() |
  | 设置Timeout参数的Thread.join()方法 |        时间结束/被调用的线程执行完毕        |
  |      LockSupport.parkNanos()       |                      -                      |
  |      LockSupport.parkUntil()       |                      -                      |

  > 调用`Thread.sleep()`方法使线程进入限期等待状态时，常使用“使一个线程睡眠”进行描述
  >
  > 调用`Object.wait()`方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述
  >
  > 阻塞和等待的区别在于，阻塞是**被动**的，它是在等待获取一个排它锁。而等待是**主**动的，通过调用 `Thread.sleep()` 和 `Object.wait()` 等方法进入。

- 死亡（Terminated）：可以是线程结束任务之后自己结束，或者产生了异常而结束



### 线程使用方式

- 实现`Runnable`接口
- 实现`Callable`接口

> 实现`Runnable`接口和`Callable`接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过`Thread.start()`来调用，可以说任务是通过线程驱动从而执行的

- 继承`Thread`类，`Thread`类也实现了`Runnable`接口，因此需要实现`run()`方法

**比起继承`Thread`类，更推荐实现接口**

Java不支持多继承，但支持实现多个接口。因此继承了`Thread`类就无法继承其他类。另外对于某些只要求执行就行的类来说，继承整个`Thread`类开销过大



### 基础线程机制

#### Executor

`Executor` 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。

主要有三种 `Executor`:

- `CachedThreadPool`: 一个任务创建一个线程；
- `FixedThreadPool`: 所有任务只能使用固定大小的线程；
- `SingleThreadExecutor`: 相当于大小为 1 的 `FixedThreadPool`。

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < 5; i++) {
        executorService.execute(new MyRunnable());
    }
    executorService.shutdown();
}
```



#### Daemon

守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。

当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。

`main()` 属于非守护线程。

使用 `setDaemon()` 方法将一个线程设置为守护线程。

```java
public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);
}
```



#### 异常处理问题

**一个线程池中的线程异常了，那么线程池（`Executors`）会怎么处理这个线程?**

`Runnable`接口中的`run`方法原型如下

```java
public void run();
```

由于所有的具体线程都需要实现`run`方法，因此线程代码不能抛出任何非运行时（`checked`）异常，只能自己消化掉（在`run`方法内使用`try-catch`把异常处理掉）。

> 这样本身也是符合线程的设计理念的，线程本身就是被看作独立的执行片断，它应该对自己负责，所以由它来消化所有的`checked`异常是很正常的。

但是，线程代码中是可以抛出错误（`Error`）和运行时异常（`RuntimeException`）的。当线程代码抛出运行时异常后，线程会中断：

> All threads that are not daemon threads have died, either by returning from the call to the run method or “by throwing an exception that propagates beyond the run method”
>
> 当所有非守护线程死亡后，要么从对`run`方法的调用返回，要么抛出超出run方法传播的异常

但是对于`invoke`此线程的主线程会产生什么影响呢？主线程不受这个影响，不会处理这个`RuntimeException`，而且根本不能`catch`到这个异常。会继续执行自己的代码 
所以得到结论：**线程方法的异常只能自己来处理。**

但是，给某个`thread`设置一个`UncaughtExceptionHandler`，可以确保在该线程出现异常时能通过回调`UncaughtExceptionHandler`接口的`public void uncaughtException(Thread t, Throwable e)` 方法来处理异常，这样的好处或者说目的是可以在线程代码边界之外（`Thread`的`run()`方法之外），有一个地方能处理未捕获异常。但是要特别明确的是：虽然是在回调方法中处理异常，但这个回调方法在执行时依然还在抛出异常的这个线程中！另外还要特别说明一点：如果线程是通过线程池创建，线程异常发生时`UncaughtExceptionHandler`接口不一定会立即回调。



下面分析两个案例：

```java
public static void main(String[] args) {
    ExecutorService executor = Executors.newCachedThreadPool();
    executor.execute(() -> sayHi("execute"));
}

private static void sayHi(String name) throws RuntimeException {
    System.out.println("SAY Hi-------" + name);
    throw new RuntimeException(name + "抛出异常");
}
```

当执行方式为`execute`时，在控制台会打印堆栈异常，`main`方法不会终止

![image-20211202212643411](https://tva1.sinaimg.cn/large/008i3skNgy1gwzt5jv96pj30lt02tmxf.jpg)



```java
public static void main(String[] args) {
    ExecutorService executor = Executors.newCachedThreadPool();
    // executor.execute(() -> sayHi("execute"));
    executor.submit(() -> sayHi("submit"));
}

private static void sayHi(String name) throws RuntimeException {
    System.out.println("SAY Hi-------" + name);
    throw new RuntimeException(name + "抛出异常");
}
```

当执行方式为`submit`时，在控制台不会打印堆栈异常，`main`方法也不会终止

![image-20211202212739822](https://tva1.sinaimg.cn/large/008i3skNgy1gwzt6hdkm0j306t02ljr5.jpg)

如果想要获取`submit`方法提交时的异常信息，就需要调用`submit`方法的返回值`Future`中的`get`方法

```java
public static void main(String[] args) {
    ExecutorService executor = Executors.newCachedThreadPool();
    // executor.execute(() -> sayHi("execute"));
    Future<?> future = executor.submit(() -> sayHi("submit"));
    try {
        future.get();
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    }
}

private static void sayHi(String name) throws RuntimeException {
    System.out.println("SAY Hi-------" + name);
    throw new RuntimeException(name + "抛出异常");
}
```

![image-20211202212926674](https://tva1.sinaimg.cn/large/008i3skNgy1gwzt8cdwwxj30qk03s3z2.jpg)



##### execute()方法分析

`execute()`方法只是把任务加入进`workQueue`中，任务的真正执行在`ThreadPoolExecutor.runWorker()`方法中

```java
// thrown用于接收任务抛出的异常，即上面sayHi方法抛出的异常
Throwable thrown = null;
try {
   // 执行任务
    task.run();
} catch (RuntimeException x) {
    thrown = x; throw x;
} catch (Error x) {
    thrown = x; throw x;
} catch (Throwable x) {
    thrown = x; throw new Error(x);
} finally {
   // 把抛出异常的任务和异常传入到afterExecute方法中，这是一个接口，可以自行对该方法进行扩展
    afterExecute(task, thrown);
}
```

在`ThreadGroup.uncaughtException()`中进行了异常处理。这个方法是由JVM来调用的，当一个线程由于未捕获异常即将终止时，JVM就会调用`Thread.getUncaughtExceptionHandler()`来查询线程指定的`uncaughtException()`处理程序，并调用这个方法。如果一个线程没有显式地设置它的`UncaughtExceptionHandler`，那么它的`ThreadGroup`对象就充当它的`UncaughtExceptionHandler`。如果`ThreadGroup`对象没有处理异常的特殊要求，它可以将调用转发给默认的未捕获异常处理程序。

```java
public void uncaughtException(Thread t, Throwable e) {
    if (parent != null) {
        parent.uncaughtException(t, e);
    } else {
        Thread.UncaughtExceptionHandler ueh =
            Thread.getDefaultUncaughtExceptionHandler();
        if (ueh != null) {
            ueh.uncaughtException(t, e);
        } else if (!(e instanceof ThreadDeath)) {
            System.err.print("Exception in thread \""
                             + t.getName() + "\" ");
            e.printStackTrace(System.err);
        }
    }
}
```

我们可以自定义异常的处理方式，即指定线程的`UncaughtExceptionHandler`，并实现其`uncaughtException()`方法

```java
ExecutorService executor = Executors.newFixedThreadPool(1, runnable -> {
    Thread thread = new Thread(runnable);
    thread.setUncaughtExceptionHandler((t, e) -> System.out.println("自定义异常处理方法"));
    return thread;
});
executor.execute(() -> sayHi("execute"));
```

![image-20211202221453326](https://tva1.sinaimg.cn/large/008i3skNgy1gwzujntsgpj308201tdfo.jpg)



##### submit()方法分析

`submit()`是一个有返回值（`FutureTask`）的执行方法，其本质也是调用了`execute()`方法，所以任务执行部分最后还是回到`ThreadPoolExecutor.runWorker()`方法

```java
// from AbstractExecutorService
public Future<?> submit(Runnable task) {
    if (task == null) throw new NullPointerException();
   // 把task封装成为一个FutureTask
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    execute(ftask);
   // 返回FutureTask
    return ftask;
}
```

再看看`FutureTask.run()`方法

```java
public void run() {
    ........
            V result;
            boolean ran;
            try {
                // call方法执行了任务，并打印了日志，抛出了异常
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
               // 异常在这里被捕获，但是没有打印堆栈异常信息，而是传入到setException方法继续处理
              // 所以调用Future.get()方法时取到在这里保存的异常时才真正抛出异常（打印堆栈异常信息），所以Future.get()方法会抛出异常，必须对其调用进行异常捕获
                setException(ex);
            }
            if (ran)
                set(result);
        }
    } 
     ......... 
}
```

在继续分析`FutureTask.get()`方法之前先说一下`FutureTask`中的一个属性——`state`：

- `NEW = 0`; 初始状态，`FutureTask`刚被创建，正在计算中都是该状态。
- `COMPLETING = 1`; 中间状态，表示计算已完成正在对结果进行赋值，或正在处理异常
- `NORMAL = 2`; 终止状态，表示计算已完成，结果已经被赋值。
- `EXCEPTIONAL = 3`; 终止状态，表示计算过程已经被异常打断。
- `CANCELLED = 4`; 终止状态，表示计算过程已经被`cancel`操作终止。
- `INTERRUPTING = 5`; 中间状态，表示计算过程已开始并且被中断，正在修改状态。
- `INTERRUPTED = 6`; 终止状态，表示计算过程已开始并且被中断，目前已完全停止。

![image-20211203120044328](https://tva1.sinaimg.cn/large/008i3skNgy1gx0iexa9thj30vm0mc42k.jpg)

> `FutureTask`中`state`的值的改变都是这样完成的：
>
> ```java
> UNSAFE.compareAndSwapInt(this, stateOffset, STATE1, STATE2)
> ```
>
> 至于`stateoffset`是这么来的
>
> ```java
> stateOffset = UNSAFE.objectFieldOffset
>     (k.getDeclaredField("state"));
> ```
>
> 其中`UNSAFE.objectFieldOffset(…)`是一个`native`方法

再看看`FutureTask.get()`方法

```java
public V get() throws InterruptedException, ExecutionException {
       // 在setException()方法中
        int s = state;
       // 如果还没有完成（未到终止状态），则等待一段时间后report
        if (s <= COMPLETING)
            s = awaitDone(false, 0L);
        return report(s);
    }
```

`report()`方法

```java
private V report(int s) throws ExecutionException {
      // outcome为在setException()方法中缓存的额一场
        Object x = outcome;
       // NORMAL为任务正常完成，返回值即可
        if (s == NORMAL)
            return (V)x;
      // 该任务被取消或中断，抛出CancellationException异常
        if (s >= CANCELLED)
            throw new CancellationException();
       // 走到这里就说明状态为EXCEPTIONAL，即因异常而中断，此时在这里抛出之前保存的异常
        throw new ExecutionException((Throwable)x);
    }
```

所以调用`FutureTask.get()`方法必须对异常进行捕获，就是在这里打印了异常堆栈信息。

```java
Future<?> future = executor.submit(() -> sayHi("submit"));
try {
    future.get();
} catch (InterruptedException | ExecutionException e) {
    e.printStackTrace();
}
```



##### 不影响其他线程任务

线程池的5种状态：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL290aGVyLzE4NDM5MDQvMjAyMDA0LzE4NDM5MDQtMjAyMDA0MjExNjE4NTE1MDItMTYyNzc3Mjc4OS5wbmc?x-oss-process=image/format,png)

- `RUNNING`：线程池处于`RUNNING`状态时，能够接收新的任务，并对已经接收的任务进行处理。线程池一旦被创建，就处于`RUNNING`状态，并且线程池中的任务数量为0。

- `SHUTDOWN`：线程池处于`SHUTDOWN`状态时，不能接收新的任务，但能对已经接收的任务进行处理。

- `STOP`：线程池处于`STOP`状态时，不能接收新的任务，也不能处理已经接收的任务，并且会中断正在执行的任务！

- `TIDYING`：所有的任务全部终止，ctl内记录的任务数量为0，线程池会变为`TIDYING`状态。

  > 当线程池变为`TIDYING`状态时，会自动执行`terminated()`钩子函数。在`ThreadPoolExecutor`中，`terminated()`函数体默认是空的，也就是说，我们可以在`TIDYING`变为`TERMINATED`时，通过重载`terminated()`，自行定义处理逻辑，`ThreadPoolExecutor`会为我们调用这段逻辑。

- `TERMINATED`：线程池彻底终止。



假设线程池中有5个线程，其中一个发生了异常，这个线程不会影响其他线程任务：

```java
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 30, TimeUnit.SECONDS, new ArrayBlockingQueue<>(10));
threadPoolExecutor.execute(() -> sayHi("execute"));
threadPoolExecutor.execute(() -> sayHi("execute"));
threadPoolExecutor.execute(() -> sayHi("exception"));
threadPoolExecutor.execute(() -> sayHi("execute"));
threadPoolExecutor.execute(() -> sayHi("execute"));
```

![image-20211204161957062](https://tva1.sinaimg.cn/large/008i3skNgy1gx1viz126hj30q405ndgh.jpg)

可见：线程池中的线程有：1、2、3、5、6，其中3号线程发生了异常，那么为什么没有4号异常？

![image-20211204162725328](https://tva1.sinaimg.cn/large/008i3skNgy1gx1vqpk3cbj30sk07ejt3.jpg)

如果发生了异常，就会走到`ThreadPoolExecutor.runWorker()`方法的`finally`块中，调用`processWorkerExit(w, completedAbruptly)`方法

![image-20211204171254127](https://tva1.sinaimg.cn/large/008i3skNgy1gx1x20xugnj30ug0hjn12.jpg)

该方法就是执行`Worker`的退出：

1. 统计完成的任务数：`completedTaskCount += w.completedTasks;`

2. 尝试终止线程池：`tryTerminate();`

   > 如果是最后一个线程退出，就会尝试终止线程池

3. 根据情况决定是否创建一个新的`Worker（addWorker(null, false)）`，一下两种情况会创建：

   - 被移除的`worker`是由于异常而死亡的：`completedAbruptly==true`
   - 被移除的`worker`是最后一个`worker`，但是工作队列中还有任务（ `!workQueue.isEmpty()`）

![image-20211204172629936](https://tva1.sinaimg.cn/large/008i3skNgy1gx1xg6hhhej31c00laq7l.jpg)



**总结**

1. 执行方式为`execute`时可以看到堆栈异常的输出
2. 执行方式为`submit`时，调用`Future.get()`可以捕获到异常
3. 线程池中一个线程发生异常，不会影响其他线程的正常执行
4. 线程池会把发生异常的线程移除掉，并创建一个新的线程放到线程池中。（由于多线程环境的并发性，线程名称（序号）可能会有些特殊）



## ThreadPoolExecutor源码解析

在 Java 中，如果每个请求到达就创建一个新线程，创建和销毁线程花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用户请求的时间和资源要多的多。
如果在一个 JVM 里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。
为了解决这个问题,就有了线程池的概念，线程池的核心逻辑是提前创建好若干个线程放在一个容器中。如果有任务需要处理，则将任务直接分配给线程池中的线程来执行就行，任务处理完以后这个线程不会被销毁，而是等待后续分配任务。同时通过线程池来重复管理线程还可以避免创建大量线程增加开销。

线程池的优势：

1. 降低创建线程和销毁线程的性能开销
2. 提高响应速度，当有新任务需要执行是不需要等待线程创建就可以立马执行
3. 合理的设置线程池大小可以避免因为线程数超过硬件资源瓶颈带来的问题

![image-20210527164849690](https://tva1.sinaimg.cn/large/008i3skNgy1gx22sftw3uj30i409agn0.jpg)



### Java中提供的线程池API

`Executors`中提供了很多线程池的工厂方法，下面是几个比较常用的：

- `newFixedThreadPool`：该方法返回一个固定数量的线程池，线程数不变，当有一个任务提交时，若线程池中空闲，则立即执行，若没有，则会被暂缓在一个任务队列中，等待有空闲的线程去执行。

  ```java
  public static ExecutorService newFixedThreadPool(int nThreads) {
      return new ThreadPoolExecutor(nThreads, nThreads,
                                    // 超出核心线程数以外的线程立即死亡
                                    0L, TimeUnit.MILLISECONDS,
                                    // 阻塞队列使用的是默认容量Integer.MAX_VALUE，相当于没有上限
                                    new LinkedBlockingQueue<Runnable>());
  }
  ```

  执行流程：

  1. 线程数 < 核心线程数，新建线程执行任务
  2. 线程数 >= 核心线程数，任务加入阻塞队列
  3. 执行完任务的线程反复去队列中取任务执行（阻塞队列中可以存放非常多的任务）
  4. 线程执行完任务后如果没有接到新任务，则立即被回收

  用途：`FixedThreadPool` 用于负载比较大的服务器，为了资源的合理利用，需要限制当前线程数量

- `newSingleThreadExecutor`: 创建一个线程的线程池，若空闲则执行，若没有空闲线程则暂缓在任务队列中。（相当于线程数为1的`FixedThreadPool`）

  ```java
  public static ExecutorService newSingleThreadExecutor() {
      return new FinalizableDelegatedExecutorService
          (new ThreadPoolExecutor(1, 1,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>()));
  }
  ```

- `newCachedThreadPool`：返回一个可根据实际情况调整线程个数的线程池，不限制最大线程数量，若有空闲的线程则执行任务，若无任务则不创建线程。并且每一个空闲线程会在 60 秒后自动回收

  ```java
  public static ExecutorService newCachedThreadPool() {
          // 没有核心线程，线程数无上限
          return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                        // 空闲时间为60s
                                        60L, TimeUnit.SECONDS,
                                        // SynchronousQueue是一个内部只能包含一个元素的队列，插入元素到队列的线程被阻塞，直到另一个线程从队列中获取了队列中存储的元素（相当于一个点）
                                        new SynchronousQueue<Runnable>());
      }
  ```

  执行流程：

  1. 没有核心线程，直接向`SynchronousQueue`中提交任务
  2. 如果有空闲线程，就去`SynchronousQueue`队列中取出任务执行；如果没有空闲线程，就新建一个
  3. 执行完任务的线程有60s存活时间，如果这个时间内没有执行新任务，就会被回收

- `newScheduledThreadPool`: 创建一个可以指定线程的数量的线程池，但是这个线程池还带有延迟和周期性执行任务的功能，类似定时器。

  ```java
  public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
      return new ScheduledThreadPoolExecutor(corePoolSize);
  }
  ```



### 构造方法

```java
public ThreadPoolExecutor(int corePoolSize,	// 核心线程数
                          int maximumPoolSize,	// 最大线程数
                          long keepAliveTime,	// 超时时间，超出核心线程数以外的线程空余存活时间
                          TimeUnit unit,	// 时间单位
                          BlockingQueue<Runnable> workQueue,	// 保存执行任务的阻塞队列
                          ThreadFactory threadFactory,	// 创建新线程使用的工厂
                          RejectedExecutionHandler handler)	// 当任务无法执行时的处理方式
```

线程池初始化时是没有创建线程的，只是初始化了上面的相关属性。



### 阻塞队列

常见的阻塞队列有以下几种：

- `ArrayBlockingQueue`：**基于数组结构的[有界阻塞队列](https://www.zhihu.com/search?q=有界阻塞队列&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A150057783})**，按先进先出对元素进行排序。
- `LinkedBlockingQueue`：**基于[链表结构](https://www.zhihu.com/search?q=链表结构&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A150057783})的有界/无界阻塞队列**，按先进先出对元素进行排序，吞吐量通常高于 `ArrayBlockingQueue`。`Executors.newFixedThreadPool` 使用了该队列。
- `SynchronousQueue`：不是一个真正的队列，而是一种在线程之间移交的机制。要将一个元素放入 `SynchronousQueue` 中，必须有另一个线程正在等待接受这个元素。如果没有线程等待，并且线程池的当前大小小于最大值，那么线程池将创建一个线程，否则根据拒绝策略，这个任务将被拒绝。使用[直接移交](https://www.zhihu.com/search?q=直接移交&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A150057783})将更高效，因为任务会直接移交给执行它的线程，而不是被放在队列中，然后由[工作线程](https://www.zhihu.com/search?q=工作线程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A150057783})从队列中提取任务。只有当线程池是无界的或者可以拒绝任务时，该队列才有实际价值。`Executors.newCachedThreadPool`使用了该队列。
- `PriorityBlockingQueue`：具有优先级的[无界队列](https://www.zhihu.com/search?q=无界队列&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A150057783})，按优先级对元素进行排序。元素的优先级是通过自然顺序或 `Comparator` 来定义的。



### 拒绝策略

常见的有以下几种：

- `AbortPolicy`：中止策略。默认的拒绝策略，直接抛出 `RejectedExecutionException`。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。
- `DiscardPolicy`：抛弃策略。什么都不做，直接抛弃被拒绝的任务。
- `DiscardOldestPolicy`：抛弃最老策略。抛弃阻塞队列中最老的任务，相当于就是队列中下一个将要被执行的任务，然后重新提交被拒绝的任务。如果阻塞队列是一个[优先队列](https://www.zhihu.com/search?q=优先队列&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A150057783})，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将该策略和[优先级队列](https://www.zhihu.com/search?q=优先级队列&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A150057783})放在一起使用。
- `CallerRunsPolicy`：调用者运行策略。在调用者线程中执行该任务。该策略实现了一种[调节机制](https://www.zhihu.com/search?q=调节机制&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A150057783})，该策略既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者（调用线程池执行任务的主线程），由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得线程池有时间来处理完正在执行的任务。



### 线程池状态-runState

在前面的异常处理问题-不影响其他线程任务中也有提及

|    运行状态    | 值   |                           状态描述                           |
| :------------: | ---- | :----------------------------------------------------------: |
|  **RUNNING**   | -1   |          接收新任务，并且也能处理阻塞队列中的任务。          |
|  **SHUTDOWN**  | 0    |      不接收新任务，但是却可以继续处理阻塞队列中的任务。      |
|    **STOP**    | 1    | 不接收新任务，同时也不处理队列任务，并且中断正在进行的任务。 |
|  **TIDYING**   | 2    | 所有任务都已终止，workercount(有效线程数)为0，线程转向 TIDYING 状态将会运行 terminated() 钩子方法。 |
| **TERMINATED** | 3    |           terminated() 方法调用完成后变成此状态。            |

![image-20210527151908663](https://tva1.sinaimg.cn/large/008i3skNgy1gx22sehdrfj30ja06wt9s.jpg)



### ctl设计

线程池内部使用ctl一个变量同时维护了两个值：运行状态`runState`和线程数量`workCount`。做法是把十进制int转换为32位二进制，其中高3位代表运行状态`runState`，而低29位代表线程数量`workCount`

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// 获取线程池状态（获取ctl高三位）
private static int runStateOf(int c)     { return c & ~CAPACITY; }
// 获取线程数量（获取ctl低29位）
private static int workerCountOf(int c)  { return c & CAPACITY; }
// 把线程池状态runState和线程数量workCount组装到一个变量ctl中
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

![image-20211204220038497](https://tva1.sinaimg.cn/large/008i3skNgy1gx25df5sd9j31pa0eitb9.jpg)

**ctl这么设计的原因和好处**

ctl 这么设计的主要好处是将对 `runState` 和 `workerCount` 的操作封装成了一个原子操作。`runState` 和 `workerCount` 是线程池正常运转中的2个最重要属性，线程池在某一时刻该做什么操作，取决于这2个属性的值。

因此无论是查询还是修改，我们必须保证对这2个属性的操作是属于“**同一时刻**”的，也就是原子操作，否则就会出现错乱的情况。如果我们使用2个变量来分别存储，要保证*原子性则需要额外进行加锁操作，这显然会带来额外的开销*，而将这2个变量封装成1个 `AtomicInteger` 则不会带来额外的加锁开销，而且只需使用简单的位操作就能分别得到 `runState` 和 `workerCount`。



### execute()

```java
public void execute(Runnable command) {
    // 参数非空校验
  	if (command == null)
        throw new NullPointerException();
    // 非原子性操作
    int c = ctl.get();
    // 添加核心线程执行任务
    if (workerCountOf(c) < corePoolSize) {
       // 如果添加核心线程执行任务则直接return结束这个方法
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 把任务放入队列workQueue.offer(command)
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // double check线程池的状态
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            // 只是创建一个新的线程，没有传入任务
            addWorker(null, false);
    }
    // 添加普通线程执行任务，如果添加失败就执行拒绝策略
    // 失败原因：1.线程池关闭；2.线程池饱和
    else if (!addWorker(command, false))
        reject(command);
}
```

> **1. 为什么需要 `double check` 线程池的状态？**
> 在多线程环境下，线程池的状态时刻在变化，而 `ctl.get()` 是非原子操作，很有可能刚获取了线程池状态后线程池状态就改变了。判断是否将 `command` 加入 `workque` 是线程池之前的状态。倘若没有 `double check`，万一线程池处于非 `running` 状态（在多线程环境下很有可能发生），那么 `command` 永远不会执行。
>
> **2、line20-为什么 `addWorker(null, false)` 的任务为`null`？**
> `addWorker(null, false)`，这个方法执行时只是创建了一个新的线程，但是没有传入任务，这是因为前面已经将任务添加到队列中了，这样可以防止线程池处于 `running` 状态，但是没有线程去处理这个任务。

![image-20210527151309059](https://tva1.sinaimg.cn/large/008i3skNgy1gx22sf9393j30ij0i9jua.jpg)



### Worker-任务

`Worker` 是 `ThreadPoolExecutor`的一个内部类，主要是**用来维护线程执行任务的中断控制状态**，它实现了`Runnable` 接口同时继承了`AQS`，实现 `Runnable` 接口意味着 `Worker` 就是一个线程，继承 `AQS` 是为了实现独占锁这个功能。

```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
{
    /** Thread this worker is running in.  Null if factory fails. */
    final Thread thread;
  	// firstTask用它来初始化时传入的第一个任务，这个任务可以有也可以为null。
  	// 如果这个值是非空的，那么线程就会在启动初期立即执行这个任务；
  	// 如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。
    Runnable firstTask;
    /** Per-thread task counter */
    volatile long completedTasks;

    Worker(Runnable firstTask) {
      	// 设置AQS中的state为-1
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker  */
    public void run() {
        runWorker(this);
    }
}
```



#### 执行任务分析

`Worker`执行任务的模型如下图所示：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9oRXgwM2NGZ1VzWEFqNk9yVVRVRFJvRzV0Q0JnbTRDSmliRmFVc1c1WWJnT1RyN0dFb1JQZWtxOU5xdm5HWTkyYmlhTUpvZHBaTUZtQTFtWnRnQUticE1BLzY0MA?x-oss-process=image/format,png)

`Worker`是通过继承`AQS`，使用`AQS`来实现独占锁这个功能。没有使用可重入锁`ReentrantLock`，而是使用`AQS`，为的就是实现不可重入的特性去反应线程现在的执行状态。

1. `lock`方法一旦获取了独占锁，表示当前线程正在执行任务中。

2. 如果正在执行任务，则不应该中断线程。

3. 如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。

4. 线程池在执行`shutdown()`方法或`tryTerminate()`方法时会调用`interruptIdleWorkers()`方法来中断空闲的线程，`interruptIdleWorkers()`方法会使用`tryLock()`方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。

在线程回收过程中就使用到了这种特性，回收过程如下图所示：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9oRXgwM2NGZ1VzWEFqNk9yVVRVRFJvRzV0Q0JnbTRDSlh2dUNLWGljVGNTZGlhUjBuRHBlYWhpYmxuZnJRdDB6VVFOdHBtZ0M0ZTFSSGV4TFB1cUtPbHVNQS82NDA?x-oss-process=image/format,png)



#### 添加工作线程-addWorker

添加线程是通过 `addWorker()` 方法来实现的：

```java
private boolean addWorker(Runnable firstTask, boolean core)
```

> **`Runnable firstTask`** 即是当前添加的线程需要执行的首个任务.
>
> **`boolean core`** 用来标记当前执行的线程是否是核心线程还是普通线程.

`execute()`方法中有三处调用了`addWorker()`：

- 当工作线程数 < 核心线程数（`workerCountOf(c) < corePoolSize`）的时候，通过`addWorker(command, true)`添加核心线程执行`command`任务。
- `double check`的时候，如果发现线程池处于正常运行状态但是里面没有工作线程，则添加个空任务和一个普通线程，这样一个 `task` 为空的 `worker` 在（非核心）线程执行的时候会去阻塞任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务。
- 队列已满的情况下，通过添加普通线程（非核心线程）去执行当前任务，如果失败了则执行拒绝策略（`reject(command)`）。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9oRXgwM2NGZ1VzWEFqNk9yVVRVRFJvRzV0Q0JnbTRDSmhycEpXNUp2TFpiM2dPelB5YUJyNVVqaWNMVEVUMEpWMDFiVG1LcFZObGtrODM5Y1NIaWIwUVNnLzY0MA?x-oss-process=image/format,png)



分为两部分看：

>  其实第一部分就是判断线程池的状态是否可以添加工作线程并接收新任务，然后添加工作线程数（还没有真正添加工作线程）

```java
retry:
for (;;) {
    int c = ctl.get();
  	// 获取线程池运行状态
    int rs = runStateOf(c);

  // 1. 线程池处于非运行状态，不接收新任务
  // 2. SHUTDOWN 状态不接受新任务，但仍然会执行已经加入任务队列的任务，所以当进入 SHUTDOWN 状态，而传进来的任务为空，并且任务队列不为空的时候，是允许添加新线程的,如果把这个条件取反，就表示不允许添加 worker
    if (rs >= SHUTDOWN &&
        ! (rs == SHUTDOWN &&
           firstTask == null &&
           ! workQueue.isEmpty()))
        return false;
  
		// 只有通过前面的校验之后才能进入第二层循环
    for (;;) {
      // 获取工作线程数
        int wc = workerCountOf(c);
      //如果工作线程数大于默认容量大小或者大于核心线程数大小，则直接返回 false 表示不能再添加 worker。
        if (wc >= CAPACITY ||
            wc >= (core ? corePoolSize : maximumPoolSize))
            return false;
        // 通过CAS方式尝试增加工作线程数
        if (compareAndIncrementWorkerCount(c))
          	// 如果添加成功，就跳出这个双循环，执行下面分析的第二部分的代码
            break retry;
        // 添加失败的话就重新获取状态
        c = ctl.get();  // Re-read ctl
        // 如果状态有变化，就跳到最外层循环执行，再次检查线程池状态
        if (runStateOf(c) != rs)
            continue retry;
        // else CAS failed due to workerCount change; retry inner loop
    }
}
```

第一个`return false`--**添加工作线程失败，不接收新任务**：

简化为

```java
 rs >= SHUTDOWN && (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())
```

- `rs >= SHUTDOWN && rs != SHUTDOWN ➡️ rs > SHUTDOWN`，即状态为`STOP`、`TIDYING`、`TERMINATED`时（不接受新任务也不处理阻塞队列中的任务）
- `rs >= SHUTDOWN && firstTask != null`，即状态为SHUTDOWN、STOP、TIDYING、TERMINATED时，且`worker`中的首个任务不为空（即阻塞队列中还有正在工作的线程，这些线程工作完成后可以继续处理剩下的任务，没必要创建新的线程）
- `rs >= SHUTDOWN && workQueue.isEmpty()`，即状态为SHUTDOWN、STOP、TIDYING、TERMINATED时，且阻塞队列`workQueue`为空（即没有线程可以处理剩下的任务了，而`SHUTDOWN`要求处理剩下的任务）

第二个`return false`--**添加工作线程失败**：

```java
wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize)
```

- 工作线程数`wc`是否超过最大容量`CAPACITY`
- 如果添加的是核心工作线程（`core`为真），判断是否超过最大核心线程容量`corePoolSize`
- 如果添加的是普通工作线程（`core`为假），判断是否超过线程池最大线程容量`maximumPoolSize`



只有第一部分执行到`break retry;`才能执行到这一部分的代码

```java
boolean workerStarted = false;
boolean workerAdded = false;
Worker w = null;
try {
  	// 创建Worker对象实例并获取其内的线程
    w = new Worker(firstTask);
    final Thread t = w.thread;
    if (t != null) {
      	// 开启可重入锁
        final ReentrantLock mainLock = this.mainLock;
      	// 独占，避免并发问题
        mainLock.lock();
        try {
            // Recheck while holding lock.
            // Back out on ThreadFactory failure or if
            // shut down before lock acquired.
          	// 获取线程池运行状态
            int rs = runStateOf(ctl.get());
						
            if (rs < SHUTDOWN ||
                (rs == SHUTDOWN && firstTask == null)) {
              	// 任务刚封装到work里还没start，线程就是alive状态？说明出现了异常
                if (t.isAlive()) // precheck that t is startable
                    throw new IllegalThreadStateException();
              	// 把worker实例添加到线程池workers
                workers.add(w);
                int s = workers.size();
              	// 如果添加线程后的线程池大小s大于曾经出现过的最大线程数，就更新
                if (s > largestPoolSize)
                    largestPoolSize = s;
              	// 设置线程添加成功标志为为true
                workerAdded = true;
            }
        } finally {
          	// 释放锁
            mainLock.unlock();
        }
      	// 如果worker实例加入线程池成功，就启动线程并修改线程启动成功标志位为true
        if (workerAdded) {
            t.start();
            workerStarted = true;
        }
    }
} finally {
    if (! workerStarted)
      	// 线程添加失败的后续操作
        //（回滚：从workers中移除worker实例，并通过CAS把第一部分中改变的workerCount减1，尝试结束线程池）
        addWorkerFailed(w);
}
return workerStarted;
```

是否可以添加线程：

```java
rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)
```

- `rs < SHUTDOWN`，也就是线程池处于`RUNNING`状态，可以创建新的线程
- `rs == SHUTDOWN && firstTask == null`，线程池处于`SHUTDOWN`状态并且`worker`中的首个任务为空（没有线程可以处理剩下的任务了，因此需要创建线程）

> 如果添加worker并且启动线程失败，就会调用`addWorkerFailed(w)`方法，主要做三件事：
>
> 1. 如果 worker 已经构造好了，则从 workers 集合中移除这个 worker
> 2. 原子递减核心线程数（因为在 `addWorker` 方法中先做了原子增加）
> 3. 尝试结束线程池



#### runWorker()

`addWorker()`方法的作用是增加工作线程，那么`runWorker()`就是线程池中执行任务的方法了，这个方法主要做了以下几件事：

1. 如果 task 不为空,则开始执行 task
2. 如果 task 为空,则通过 `getTask()`再去取任务,并赋值给 task,如果取到的 `Runnable` 不为空,则执行该任务
3. 执行完毕后,通过 while 循环继续 `getTask()`取任务（这个while循环，就是实现线程复用的地方）
4. 如果 `getTask()`取到的任务依然是空,那么整个 `runWorker()`方法执行完毕

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9oRXgwM2NGZ1VzWEFqNk9yVVRVRFJvRzV0Q0JnbTRDSmhVeGQzeFh0MlFhN1JjbmQ4ZVBSZk5ndjhnUGZkR1FNbE5hZFIwcmU2SXNFOTgyT3BhdVFmZy82NDA?x-oss-process=image/format,png)

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
  	// 由于Worker初始化时AQS中state设置为-1，这里要先做一次解锁把state更新为0，允许线程中断
    // interruptIfStarted()中只有 state>=0 才允许调用中断
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        // 循环的判断任务（firstTask或从队列中获取的task）是否为空
       // 这个while循环，就是实现线程复用的地方
        while (task != null || (task = getTask()) != null) {
            // Worker加锁，本质是AQS获取资源并且尝试CAS更新state由0更变为1
            w.lock();
            // 如果线程池运行状态是stopping, 确保线程是中断状态;
       		  // 如果不是stopping, 确保线程是非中断状态. 
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                  	// 运行任务
                    task.run();
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
              	// worker完成任务数+1
                w.completedTasks++;
              	// 解锁，把state重新更新为0
                w.unlock();
            }
        }
      	// 走到这里说明某一次getTask()返回为null，线程正常退出
        completedAbruptly = false;
    } finally {
      	// 处理线程退出
        processWorkerExit(w, completedAbruptly);
    }
}
```

> 上面的代码中可以看到有`beforeExecute`、`afterExecute`和`terminated`三个函数，它们都是钩子函数，可以分别在子类中重写它们用来扩展`ThreadPoolExecutor`，例如添加日志、计时、监视或者统计信息收集的功能。
>
> - `beforeExecute()`：线程执行之前调用
> - `afterExecute()`：线程执行之后调用
> - `terminated()`：线程池退出时候调用



#### getTask()

```java
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
      	// 获取线程池状态
        int c = ctl.get();
        int rs = runStateOf(c);

        // 1.线程池状态是STOP，TIDYING，TERMINATED
        // 2.线程池SHUTDOWN并且队列是空的.
        // 满足以上两个条件之一则工作线程数wc减去1，然后直接返回null（获取任务失败）
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }
				// 获取工作线程数
        int wc = workerCountOf(c);

        // 允许核心工作线程对象销毁淘汰或者工作线程数 > 最大核心线程数corePoolSize
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

      	// 1.工作线程数 > 最大线程数maximumPoolSize 或者timed == true && timedOut == true
        // 2.工作线程数 > 1 或者队列为空 
        // 同时满足以上两个条件则通过CAS把线程数减去1，同时返回null。CAS把线程数减去1失败会进入下一轮循环做重试
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
          	 // 如果timed为true，通过poll()方法做超时拉取，keepAliveTime时间内没有等待到有效的任务，则返回null
            // 如果timed为false，通过take()做阻塞拉取，会阻塞到有下一个有效的任务时候再返回（一般不会是null）
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

> 里面有个关键字`allowCoreThreadTimeOut`，它的默认值为false，在Java1.6开始你可以通过`threadPoolExecutor.allowCoreThreadTimeOut(true)`方式来设置为true，即是否允许核心线程超时销毁。

**默认的情况下核心线程数量会一直保持，即使这些线程是空闲的它也是会一直存在的，而当设置为 true 时，线程池中 `corePoolSize` 线程空闲时间达到 `keepAliveTime` 也将销毁关闭。**



### 总结

参考知乎https://zhuanlan.zhihu.com/p/150057783

1. **使用线程池的好处？**

   1. 降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。
   2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
   3. 增加线程的可管理型。线程是稀缺资源，使用线程池可以进行统一分配，调优和监控。

2. **线程池的运作流程**

   ![img](https://pic4.zhimg.com/80/v2-1c6ce358830df9eef44f96c74317cfcb_720w.jpg)

3. **阻塞队列的使用注意事项？**

   - 使用有界队列时，需要注意线程池满了之后，被拒绝的任务如何处理
   - 使用无界队列时，需要注意如果任务的提交速度大于线程池的处理速度，可能会导致内存溢出

4. **在我们实际使用中，线程池的大小配置多少合适？**

   要想合理的配置线程池大小，首先我们需要区分任务是计算密集型还是I/O密集型。

   对于计算密集型，设置 线程数 = CPU数 + 1，通常能实现最优的利用率。

   对于I/O密集型，网上常见的说法是设置 线程数 = CPU数 * 2 ，这个做法是可以的，但个人觉得不是最优的。

   在我们日常的开发中，我们的任务几乎是离不开I/O的，常见的网络I/O（RPC调用）、磁盘I/O（数据库操作），并且I/O的等待时间通常会占整个任务处理时间的很大一部分，在这种情况下，开启更多的线程可以让 CPU 得到更充分的使用，一个较合理的计算公式如下：

   线程数 = CPU数 * CPU利用率 * (任务等待时间 / 任务计算时间 + 1)

   例如我们有个定时任务，部署在4核的服务器上，该任务有100ms在计算，900ms在I/O等待，则线程数约为：4 * 1 * (1 + 900 / 100) = 40个。

   当然，具体我们还要结合实际的使用场景来考虑。













